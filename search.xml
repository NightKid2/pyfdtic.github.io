<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Ansible-基本原理与安装配置]]></title>
    <url>%2F2018%2F03%2F15%2FAnsible-%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86%E4%B8%8E%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[Ansible 基本原理, 安装配置与命令行工具的使用. 1. Ansible 简介Ansible 是使用 Python 开发的, 基于 SSH 协议的, Agentless 的配置管理工具. 其源代码存放于 githb 上, 分隔成 三部分 分别存放在不同的代码仓库上. 主仓库 : https://github.com/ansible/ansible 核心模块 : https://github.com/ansible/ansible-modules-core 其他模块 : https://github.com/ansible/ansible-modules-extras 2. Ansible 任务的执行细节原理2.1 角色与依赖: 被管理主机 : 需要 ssh 和 python2.5 或者更高版本. 管理主机 : 需要 Python2.6 或者更高的版本. 有些模块需要额外的依赖, 如 ec2模块 依赖 boto模块, docker 模块依赖 docker-py 等. 2.2 工作机制Ansible 默认采用推送模式, 但是也支持 拉取模式, 使用 ansible-pull 命令. 2.3 工作原理示例代码: - name: install nginx apt: name=nginx ansible 操作如下: 在管理主机生成安装 nginx 软件包的 python 程序 将该程序复制到 目标服务器. 在目标服务器上完成操作, 执行 程序 等待改程序在所有主机上完成. ansible 执行模块指令的注意事项: 对于每一个任务, ansible 都是并行执行的. 在开始下一个任务之前, ansible 会等待所有主机都完成上一个任务. ansible 任务的执行顺序, 为管理员定义的执行顺序. 幂等性 3. 安装配置3.1 安装12$ yum install python-pip$ pip install ansible 3.2 配置文件 配置段 ansible.cfg 有 defaults, ssh_connection, paramiko, accelerate 四个配置段, 其具体配置项见ansible 番外篇之 ansible.cfg 配置参数 配置文件及优先级 ansible 配置文件 : ansible.cfg, ansible 使用如下位置和顺序来查找 ansible.cfg 文件 ANSIBLE_CONFIG 环境变量指向的文件 ./ansible.cfg ~/.ansible.cfg /etc/ansible/ansible.cfg 基础示例: [defaults] hostfile = hosts remote_user = ec2-user private_key_file = /path/to/my_private_key host_key_checking = False # 关闭 host key 检查. 4. Ansible 抽象实体4.1 inventoryAnsible 执行的目标主机的配置文件. Ansible 支持静态 Inventory 文件 和 动态 Inventory , 默认的 静态 Inventory 文件为 /etc/ansible/hosts, 同时支持 Cobbler Inventory , AWS ec2.py 等动态 Inventory. 4.2 变量与factAnsible 支持如下变量类型及定义, 可以提高 task 的可复用性和适用性: 自定义变量 注册变量 内置变量 fact 变量 4.3 模块模块定义 Ansible 可以在目标主机执行的具体操作, 是由 Ansible 包装好后在这几上执行一系列操作的脚本, 是 Ansible 执行操作的最小粒度.Ansible 支持如下模块类型: 内置模块 自定义模块: 支持多种编程语言, 如 shell, python, ruby 等. 4.4 task/play/role/playbook task : 由模块定义的具体操作. play : 多个包含 host, task 等多个字段部分的任务定义集合. 是一个 YAML 字典结构. playbook : 多个 play 组成的列表 role : 是将 playbook 分割为多个文件的主要机制, 用于简化 playbook 的编写, 并提高 playbook 的复用性. 5. Ansible 命令5.1 ansible123456789101112131415161718192021$ ansible -i INVENTORY HOST_GROUP [ -s ] -m MODEL -a ARGS [-vvvv] -i INVENTORY : 指定 INVENTORY -s : sudo 为 root 执行 -m MODEL : 模块 -a ARGS : 模块参数 -vvvv : 输出详细信息.# 检测是否可以连接到服务器.$ ansible testserver -i hosts -m ping [-vvvv]# 查看服务器运行时间$ ansible testserver -i hosts -m command -a uptime# 参数中包含空格, 应该使用 引号 引起来.$ ansible testserver -i hosts -m command -a "tail /var/log/messages"# 安装 nginx 包$ ansible testserver -s -m apt -a name=nginx# 重启 nginx 服务$ ansible testserver -s -m service -a name=nginx state=restarted 5.2 ansible-docAnsible 模块的帮助文档. 12345678# 列出所有可用模块$ ansible-doc --list # 查看指定 模块的帮助$ ansible-doc MOD_NAME# 查看模块的示例$ ansible-doc MOD_NAME -s 5.3 ansible-galaxyansible-galaxy : 创建 role 初始文件和目录 5.3.1 创建初始 role 文件和目录$ ansible-galaxy init -p playbook/roles web -p /path/to/roles : 指定 roles 的目录, 未指定则为当前目录. 5.3.2 从 role 仓库中检索, 安装,删除 role.ansible-galaxy [delete|import|info|init|install|list|login|remove|search|setup] [--help] [options] # 检索 $ ansible-galaxy search ntp # 安装 $ ansible-galaxy install -p ./roles bennojoy.ntp # 列出 $ ansible-galaxy list # 删除 $ ansible-galaxy remove bennojoy.ntp 5.4 ansible-vaultansible-vault 用于创建和编辑加密文件, ansible-playbook 可以自动识别并使用密码解密这些文件. 5.4.1 ansible-vault 命令$ ansible-vault [create|decrypt|edit|encrypt|encrypt_string|rekey|view] [--help] [options] vaultfile.yml SubCmd: - encrypt : 加密 - decrypt : 解密 - create : 创建 - edit : 编辑 - view : 查看 - rekey : 修改密码 Options: --ask-vault-pass : ask for vault password --new-vault-password-file=NEW_VAULT_PASSWORD_FILE : new vault password file for rekey --output=OUTPUT_FILE : output file name for encrypt or decrypt; use - for stdout --vault-password-file=VAULT_PASSWORD_FILE : vault password file -v, --verbose : verbose mode (-vvv for more, -vvvv to enable connection debugging) --version : show program&apos;s version number and exit 5.4.2 与playbook 结合的使用 在 playbook 中引用 vault 文件: 可以在 vars_file 区段像一般文件一样易用 vault 加密的文件. 即, 如果加密了一个 file 文件, 在 playbook 中也无需修改. ansible-playbook 使用用 --ask-value-pass 或 --vault-password-file 参数 $ ansible-playbook myplay.yml --ask-value-pass # password.file 可以为文本文件, 如果该为文件可执行脚本, 则 ansible 使用它的标准输出内容作为密码 $ ansible-playbook myplay.yml --vault-password-file /path/to/password.file 5.5 ansible-playbook5.5.1 命令行参数Usage: ansible-playbook playbook.yml Options: --ask-vault-pass ask for vault password -C, --check don&apos;t make any changes; instead, try to predict some of the changes that may occur -D, --diff when changing (small) files and templates, show the differences in those files; works great with --check -e EXTRA_VARS, --extra-vars=EXTRA_VARS set additional variables as key=value or YAML/JSON --flush-cache clear the fact cache --force-handlers run handlers even if a task fails -f FORKS, --forks=FORKS specify number of parallel processes to use (default=5) -i INVENTORY, --inventory-file=INVENTORY specify inventory host path (default=./hosts) or comma separated host list. -l SUBSET, --limit=SUBSET further limit selected hosts to an additional pattern --list-hosts outputs a list of matching hosts; does not execute anything else --list-tags list all available tags --list-tasks list all tasks that would be executed -M MODULE_PATH, --module-path=MODULE_PATH specify path(s) to module library (default=None) --new-vault-password-file=NEW_VAULT_PASSWORD_FILE new vault password file for rekey --output=OUTPUT_FILE output file name for encrypt or decrypt; use - for stdout --skip-tags=SKIP_TAGS only run plays and tasks whose tags do not match these values --start-at-task=START_AT_TASK start the playbook at the task matching this name --step one-step-at-a-time: confirm each task before running --syntax-check perform a syntax check on the playbook, but do not execute it -t TAGS, --tags=TAGS only run plays and tasks tagged with these values --vault-password-file=VAULT_PASSWORD_FILE vault password file -v, --verbose verbose mode (-vvv for more, -vvvv to enable connection debugging) Connection Options: control as whom and how to connect to hosts -k, --ask-pass ask for connection password --private-key=PRIVATE_KEY_FILE, --key-file=PRIVATE_KEY_FILE use this file to authenticate the connection -u REMOTE_USER, --user=REMOTE_USER connect as this user (default=root) -c CONNECTION, --connection=CONNECTION connection type to use (default=smart) -T TIMEOUT, --timeout=TIMEOUT override the connection timeout in seconds (default=10) --ssh-common-args=SSH_COMMON_ARGS specify common arguments to pass to sftp/scp/ssh (e.g. ProxyCommand) --sftp-extra-args=SFTP_EXTRA_ARGS specify extra arguments to pass to sftp only (e.g. -f, -l) --scp-extra-args=SCP_EXTRA_ARGS specify extra arguments to pass to scp only (e.g. -l) --ssh-extra-args=SSH_EXTRA_ARGS specify extra arguments to pass to ssh only (e.g. -R) Privilege Escalation Options: control how and which user you become as on target hosts -s, --sudo run operations with sudo (nopasswd) (deprecated, use become) -U SUDO_USER, --sudo-user=SUDO_USER desired sudo user (default=root) (deprecated, use become) -S, --su run operations with su (deprecated, use become) -R SU_USER, --su-user=SU_USER run operations with su as this user (default=root) (deprecated, use become) -b, --become run operations with become (does not imply password prompting) --become-method=BECOME_METHOD privilege escalation method to use (default=sudo), valid choices: [ sudo | su | pbrun | pfexec | doas | dzdo | ksu | runas ] --become-user=BECOME_USER run operations as this user (default=root) --ask-sudo-pass ask for sudo password (deprecated, use become) --ask-su-pass ask for su password (deprecated, use become) -K, --ask-become-pass ask for privilege escalation password 部分示例 -e var=valur : 传递变量给 playbook # 列出主机, 但不会执行 playbook $ ansible-playbook -i hosts --list-hosts web-tls.yml # 语法检查 $ ansible-playbook --syntax-check web-tls.yml # 列出 task, 但不会执行 playbook $ ansible-playbook -i hosts --list-tasks web-tls.yml # 检查模式, 会检测 playbook 中的每个任务是否会修改主机的状态, 但并不会对主机执行任何实际操作. # 需要注意 playbook 中的 task 中的依赖关系, 可能会报错. $ ansible-playbook [ -C | --check ] web-tls.yml # diff 将会为任何变更远程主机状态的文件输出差异信息. 与 --check 结合尤其好用. $ ansible-playbook [ -D | --diff ] playbook.yml 5.5.2 ansible-playbook 控制 task 的执行 step --step 参数会在执行每个 task 之前都做提示. $ ansible-playbook --step playbook.yml Perform task: install package (y/n/c) : y : 执行 n : 不执行, 跳过 c : 继续执行剩下 playbook , 并不再提示. start-at-task --start-at-task 用于让 ansible 从指定 task 开始运行 playbook, 而不是从头开始. 常用于 playbook 中存在 bug , 修复之后, 从bug处再次重新运行. tags ansible 允许对一个 task 或者 play 添加一个或多个 tags, 如: - hosts: myservers tags: - foo tasks: - name: install packages apt: name={{ item }} with_items: - vim - emacs - nano - name: run arbitrary command command: /opt/myprog tags: - bar - quux -t TAG_NAME 或 --tags TAG_NAME 告诉 ansible 仅允许具有指定 tags 的 task 或 play. --skip-tags TAG_NAME 告诉 ansible 跳过具有指定 tags 的 task 或者 play. # 仅允许指定 tags 的 task/play $ ansible-playbook -t foo,bar playbook.yml $ ansible-playbook --tags=foo,bar playbook.yml # 跳过指定 tags 的 task/play $ ansible-playbook --skip-tags=baz,quux playbook.yml 5.6 ansible-consoleREPL console for executing Ansible tasks $ ansible-console [&lt;host-pattern&gt;] [options] 5.7 ansible-configView, edit and manage ansible configuratin $ ansible-config [view|dump|list] [--help] [options] [ansible.cfg] 5.8 ansible-inventoryused to display or dump the configured inventory as Ansible sees it. $ ansible-inventory [options] [host|group] 5.9 ansible-pullpulls playbooks from a VCS repo and executes them for the local host. $ ansible-pull -U &lt;repository&gt; [options] [&lt;playbook.yml&gt;] 6. ansible 优化加速6.1 SSH Multiplexing (ControlPersist)原理 : 第一次尝试 SSH 连接到远程主机时, OpenSSH 创建一个主链接 OpenSSH 创建一个 UNIX 域套接字(控制套接字), 通过主链接与远程主机相连接 在 ControlPersist 超时时间之内, 再次连接到该远程主机, OpenSSH 将使用控制套接字与远程主机通信, 而不创建新的 TCP 连接, 省去了 TCP 三次握手的时间. Ansible 支持的 SSH Multiplexing 选项列表: 选项 值 说明 ControlMaster auto 开启 ControlPersist ControlPath $HOME/.ansible/cp/ansible-ssh-%h-%p-%r UNIX 套接字文件存放路径, 操作系统对 套接字 的最大长度有限制, 所以太长的套接字, 则 ControlPersist 将不工作, 并且 Ansible 不会报错提醒. ControlPersist 60s SSH 套接字连接空闲时间, 之后关闭 如果启用了 SSH Multiplexing 设置, 并且变更了 SSH 连接的配置, 如修改了 ssh_args 配置项, 那么, 新配置对于之前连接打开的未超时的控制套接字不会生效. 6.2 fact 缓存 关闭 fact 缓存 # ansible.cfg [defaults] gathering=explicit 开启 fact 缓存 请确保, playbook 中没有指定 gather_facts: True 或 gather_facts: False 配置项. # ansible.cfg [defaults] gathering=smart # 缓存过期时间, 单位 秒 fact_cache_timeout=86400 # 缓存实现机制. fact_caching=... JSON ansible 将fact 缓存写入到 JSON 文件中, Ansible 使用文件修改时间来决定fact 缓存是否过期. # ansible.cfg [defaults] gathering=smart # 缓存过期时间, 单位 秒 fact_cache_timeout=86400 fact_caching = jsonfile # 指定 fact 缓存文件保存目录 fact_caching_connection = /tmp/ansible_fact/cache redis 需要安装 redis 包, $ pip install redis; 需要本机提供 redis 服务. # ansible.cfg [defaults] gathering=smart # 缓存过期时间, 单位 秒 fact_cache_timeout=86400 fact_caching = redis memcache 需要安装 python-memcached 包, $ pip install python-memcached; 需要本机提供 memcached 服务. # ansible.cfg [defaults] gathering=smart # 缓存过期时间, 单位 秒 fact_cache_timeout=86400 fact_caching = memcached 希望在 playbook 云子能够之前清除 fact 缓存, 使用 --flush-cache 参数 6.3 pipeline原理: 默认执行 task 步骤: 首先, 基于调用的 module 生成一个 python 脚本; 将 Python 脚本复制到远程主机; 最后, 执行 Python 脚本. 将产生两个 SSH 会话. pipeline 模式 : Ansible 执行 Python 脚本时, 并不复制他, 而是通过管道传递给 SSH 会话, 从而减少了 SSH 会话的数目, 节省时间. 配置: 控制主机开启 pipeline # ansible.cfg [defaults] pipeline=True 远程主机 /etc/sudoers 中的 requiretty 没有启用. Defaults: !requiretty 6.4 并发 设置 ANSIBLE_FORKS 环境变量 修改 ansible.cfg 配置文件, forks = 20.]]></content>
      <categories>
        <category>DevOps</category>
      </categories>
      <tags>
        <tag>ansible</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Ansible-task-role-playbook.md]]></title>
    <url>%2F2018%2F03%2F15%2FAnsible-task-role-playbook%2F</url>
    <content type="text"><![CDATA[使用 Ansible task, role, playbook 定义任务, 实现自动化服务器管理. task name : 可选配置, 用于提示task 的功能. 另, ansible-playbook –start-at-task &lt;task_name&gt; 可以调用 name, 从 task 的中间开始执行. 模块(功能) : 必选配置, 有模块的名称组成的 key 和 模块参数组成的 value. 从 Ansible 前段所使用的 YAML 解析器角度看, 参数将被按照字符串处理, 而不是字典 apt: name=nginx update_cache=yes 复杂参数: ansible 提供一个将模块调用分隔成多行的选择, 可以传递 key 为变量名的字典, 而不是传递字符串参数. 这种方式, 在调用拥有复杂参数的模块时, 十分有用. 如 ec2 模块. - name: install pip pkgs pip: name: &quot;{{ item.name }}&quot; version: &quot;{{ item.version }}&quot; virtualenv: &quot;{{ venv_path }}&quot; with_items: - {name: mazzanine, version: 3.1.10} - {name: gunicorn, version: 19.1.1} environment : 设置环境变量 传入包含变量名与值的字典, 来设置环境变量. - name: set the site id script: scripts/setsite.py environment: PATH: &quot;{{ venv_path }}/bin&quot; PROJECT_DIR: &quot;{{ proj_path }}&quot; ADMIN_PASS: &quot;{{ admin_pass }}&quot; sudo, sudo_user notify 触发 handler 任务. when 当 when 表达式返回 True 时, 执行该 task , 否则不执行. local_action : 运行本地任务 在控制主机本机上(而目标主机)执行命令. 如果目标主机为多台, 那么, local_action 执行的task 将执行多次, 可以指定 run_once , 来限制 local_action 的执行次数. # 调用 wait_for 模块 : 注: inventory_hostname 的值仍然是远程主机, 因为这些变量的范围仍然是远程主机, 即使 task 在本机执行. - name: wait for ssh server to be running local_action: wait_for port=22 host=&quot;{{ inventory_hostname }}&quot; search_regex=OpenSSH # 调用 command 模块 - name: run local cmd hosts: all gather_facts: False tasks: - name: run local shell cmd local_action: command touch /tmp/new.txtxt delegate_to: 在涉及主机之外的主机上运行 task 使用场景: 在报警主机中, 启用基于主机的报警, 如 Nagios 向负载均衡器中, 添加一台主机, 如 HAProxy # 配置 Nagios 示例, inventory_hostname 仍然指 web 主机, 而非 nagios_server.example.com . - name: enable alerts for web servers hosts: web tasks: - name: enable alerts nagios: action=enanle_alerts service=web host={{ inventory_hostname }} delegate_to: nagios_server.example.com --- # This playbook does a rolling update for all webservers serially (one at a time). # Change the value of serial: to adjust the number of server to be updated. # # The three roles that apply to the webserver hosts will be applied: common, # base-apache, and web. So any changes to configuration, package updates, etc, # will be applied as part of the rolling update process. # # gather facts from monitoring nodes for iptables rules - hosts: monitoring tasks: [] - hosts: webservers serial: 1 # These are the tasks to run before applying updates: pre_tasks: - name: disable nagios alerts for this host webserver service nagios: &apos;action=disable_alerts host={{ inventory_hostname }} services=webserver&apos; delegate_to: &quot;{{ item }}&quot; with_items: groups.monitoring - name: disable the server in haproxy haproxy: &apos;state=disabled backend=myapplb host={{ inventory_hostname }} socket=/var/lib/haproxy/stats&apos; delegate_to: &quot;{{ item }}&quot; with_items: groups.lbservers roles: - common - base-apache - web # These tasks run after the roles: post_tasks: - name: wait for webserver to come up wait_for: &apos;host={{ inventory_hostname }} port=80 state=started timeout=80&apos; - name: enable the server in haproxy haproxy: &apos;state=enabled backend=myapplb host={{ inventory_hostname }} socket=/var/lib/haproxy/stats&apos; delegate_to: &quot;{{ item }}&quot; with_items: groups.lbservers - name: re-enable nagios alerts nagios: &apos;action=enable_alerts host={{ inventory_hostname }} services=webserver&apos; delegate_to: &quot;{{ item }}&quot; with_items: groups.monitoring run_once : 值为 True/False 该 task 是否只运行一次, 与 local_action 配合十分好用. changed_when &amp; failed_when 使用 changed_when 和 failed_when 语句改变 Ansible 对 task 是 chenged 状态还是 failed 状态的认定.需要了解命令的输出结果 - name: initialize the database django_manage: command: createdb --noinput --nodata app_path: &quot;{{ proj_path }}&quot; virtualenv: &quot;{{ venv_path }}&quot; register: result changed_when: not result.failed and &quot;Creating tables&quot; in result.out failed_when: result.failed and &quot;Database already created&quot; not in result.msg 循环 playbook 执行后, 跟踪主机状态.playplay 可以想象为连接到主机(host)上执行任务(task)的事务. 选项: host : 必选配置, 需要配置的一组主机 task : 必选配置, 需要在主机上执行的任务 name : 可选配置, 一段注释, 用来描述 play 的功能, ansible 在 play 开始执行的时候, 会把 name 打印出来. sudo : 可选配置, 如果为真, ansible 会在运行每个 task 的时候, 都是用 sudo 命令切换为 (默认) root. vars : 可选配置, 变量与其值组成的列表. 任何合法的 YAML 对象都可以作为变量的值. 变量不仅可以在 tasks 中使用, 还可以在 模板文件 中使用. vars_files : 可选, 把变量放到一个或者多个文件中. gather_facts : 是否收集 fact. handlers : 可选, ansible 提供的 条件机制, 和 task 类似, 但只有在被 task 通知的时候才会运行. 如果 ansible 识别到 task 改变了系统的状态, task 就会触发通知机制. task 将 handler 的名字作为参数传递, 依此来通知 handler. handler 只会在所有任务执行完成之后执行, 而且即使被通知了多次, 也只会执行一次. handler 按照play 中定义的顺序执行, 而不是被通知的顺序. handler 常见的用途就是重启服务和重启服务器. serial, max_fail_percentage 默认情况下, Ansible 会并行的在所有相关联主机上执行每一个 task. 可以使用 serial 限制并行执行 play 的主机数量. 一般来说, 当 task 失败时, Ansible 会停止执行失败的那台主机上的任务, 但是继续对其他主机执行. 在负载均衡场景中, 可能希望 Ansible 在所有主机都发生失败前让整个 play 停止执行, 否则将会导致, 所有主机都从 负载均衡器上移除, 并且全部执行失败, 最终负载均衡器上没有任何主机的局面. 此时, 可以使用 serial 和 max_fail_percentage 语句来指定, 最大失败主机比例达超过 max_fail_percentage 时, 让整个 play 失败. 如果希望 Ansible 在任何主机出现 task 执行失败的时候, 都放弃执行, 则需要设置max_fail_percentage=0. - name: upgrade packages on servers behind load balancer hosts: myhosts serial: 1 max_fail_percentage: 25 tasks: - name: get the ec2 instance id and elastic load balancer id ec2_facts: - name: task the out of the elastic load balancer local_action: ec2_elb args: instance_id: &quot;{{ ansible_ec2_instance_id }}&quot; state: absent - name: upgrade packages apt: update_cache=yes upgrade=yes - name: put the host back in the elastic load balancer local_action: ec2_elb args: instance_id: &quot;{{ ansible_ec2_instance_id }}&quot; state: present ec2_elbs: &quot;{{ item }}&quot; with_items: ec2_elbs roles pre-task post-task rolerole 是将 playbook 分隔为多个文件的主要机制, 他大大简化了复杂 playbook 的编写, 同时使得 role 更加易于复用. role 的基本构成.每个 role 都会用一个名字, 如 ‘database’, 与该 role 相关的文件都放在 roles/database 目录下. 其结构如下: 每个单独文件都是可选的 task: task 定义 roles/database/tasks/main.yml files 需要上传到目标主机的文件: roles/database/files/ templates Jinja2 模板文件 roles/database/templates handlers handler roles/database/handler/main.yml vars 不应被覆盖的变量 roles/database/vars/main.yml defaults 可以被覆盖的默认变量 roles/database/default/main.yml meta role 的依赖信息 roles/database/meta/main.yml default 变量与 vars 变量: default : 希望在 role 中变更变量的值. vars : 不希望变量的值变更. role 中变量命名的一个良好实践: 变量建议以 role 的名称开头, 因为在 Ansible 中不同的 role 之间没有命名空间概念, 这意味着在其他 role 中定义的变量, 或者再 playbook 中其他地方定义的变量, 可以在任何地方被访问到. 如果在两个不同的 role 中使用了同名的变量, 可能导致意外的行为. role 的存放位置 playbook 并列的 roles 目录下; /etc/ansible/roles/ 下 ansible.cfg 中 default 段 roles_path 指向的位置 环境变量 ANSIBLE_ROLES_PATH 指向的位置 在 playbook 中使用 role# mezzaning-single-host.yml - name: deploy mezzanine on vagrant hosts: web vars_file: - secrets.yml roles: - role: database database_name: &quot;{{ mezzanine_proj_name }}&quot; # 定义覆盖变量 database_pass: &quot;{{ mezzanine_proj_name }}&quot; # 定义覆盖变量 - role: mezzanine live_hostname: 192.168.33.10.xip.io domains: - 192.168.33.10.xip.io - www.192.168.33.10.xip.io # mezzaning-across-host.yml - name: deploy postgres vagrant hosts: db vars_files: - secrets.yml roles: - role: database database_name: &quot;{{ mezzanine_proj_name }}&quot; # 定义覆盖变量 database_pass: &quot;{{ mezzanine_proj_name }}&quot; # 定义覆盖变量 - name: deploy mezzanine on vagrant hosts: web vars_files: - secrets.yml roles: - role: mezzanine database_host: &quot;{{ hostvars.db.ansible_eth1.ipv4.address }}&quot; live_hostname: 192.168.33.10.xip.io domains: - 192.168.33.10.xip.io - www.192.168.33.10.xip.io pre-task &amp; post-taskpre-task : 定义在 role 执行之前, 执行的 taskpost-task : 定义在 role 执行之后, 执行的 task. - name: deploy mezzanine on vagrant hosts: web vars_files: - secrets.yml pre_tasks: - name: update the apt cache apt: update_cache=yes roles: - role: mezzanine database_host: &quot;{{ hostvars.db.ansible_eth1.ipv4.address }}&quot; live_hostname: 192.168.33.10.xip.io domains: - 192.168.33.10.xip.io - www.192.168.33.10.xip.io post_tasks: - name: notify Slack that the servers have been updated local_action:&gt; slack domain=acme.slack.com token={{ slack_token }} msg=&quot;web server {{ inventory_hostname }} configured&quot; inclued用于调用位于同一目录下的其他 定义文件, 可用于 Tasks,Playbook, Vars, Handler, Files 等. # task example --- - name: install apt packages apt: pkg={{ item }} update_cache=yes cache_valid_time=3600 sudo: True with_items: - git - libjpeg-dev - libpq-dev - memcached - nginx - include: django.yml - include: nginx.yml # example 2 --- - name: check host environment include: check_environment.yml - name: include OS family/distribution specific variables include_vars: &quot;{{ item }}&quot; with_first_found: - &quot;../defaults/{{ ansible_distribution | lower }}-{{ ansible_distribution_version | lower }}.yml&quot; - &quot;../defaults/{{ ansible_distribution | lower }}.yml&quot; - &quot;../defaults/{{ ansible_os_family | lower }}.yml&quot; - name: debug variables include: debug.yml tags: - debug ansible-galaxy : 创建 role 初始文件和目录 创建初始 role 文件和目录 $ ansible-galaxy init -p playbook/roles web -p /path/to/roles : 指定 roles 的目录, 未指定则为当前目录. 从 role 仓库中检索, 安装,删除 role. ansible-galaxy [delete|import|info|init|install|list|login|remove|search|setup] [--help] [options] 检索 $ ansible-galaxy search ntp 安装 $ ansible-galaxy install -p ./roles bennojoy.ntp 列出 $ ansible-galaxy list 删除 $ ansible-galaxy remove bennojoy.ntp 在线网站 https://galaxy.ansible.com dependent role:dependent role 用于指定 role 依赖的其他一个或多个 role, Ansible 会确保被指定依赖的role 一定会优先被执行. Ansible 允许向 dependent role 传递参数 dependent role 一般在 myrole/meta/main.yml 中指定. # roles/web/meta/main.yml dependencies: - { role: ntp, ntp_server=ntp.ubuntu.com } - { role: common } - { role: memcached } playbook : 用于实现 ansible 配置管理的脚本.playbook 其实就是一个字典组成的列表. 一个 playbook 就是一组 play 组成的列表. 一个 play 由 host 的无序集合与 task 的有序列表组成. 每一个 task 由一个模块构成. ansible 中的 True/False 和 yes/no模块参数(如 update_cache=yes)对于值的处理, 使用字符串传递: 真值 yes,on,1,true 假值 no,off,0,false 其他使用 YAML 解析器来处理: 真值 true,True,TRUE,yes,Yes,YES,on,On,ON,y,Y 假值 false,False,FALSE,no,No,NO,off,Off,OFF,n,N 推荐做法: 模块参数: yes/no 其他地方: True,False playbook 文件的执行方法: 使用 ansible-playbook 命令 $ ansible-playbook myplaybook.yml shebang $ chmod +x myplaybook.yml $ head -n 1 myplaybook.yml #!/usr/bin/env ansible-playbook $ ./myplaybook.yml 当 Ansible 开始运行 playbook 的时候, 他做的第一件事就是从他连接到的服务器上收集各种信息. 这些信息包括操作系统,主机名,网络接口等. 建立 nginx web 服务器$ cat web-notls.yml - name: Configure webserver with nginx and tls hosts: webservers sudo: true vars: key_file: /etc/nginx/ssl/nginx.key cert_file: /etc/nginx/ssl/nginx.crt conf_file: /etc/nginx/sites-available/default server_name: localhost tasks: - name: install nginx apt: name=nginx update_cache=yes cache_valid_time=3600 - name: create directories for ssl certificates file: path=/etc/nginx/ssl state=directory - name: copy TLS key copy: src=files/nginx.key desc={{ key_file }} owner=root mode=06-- notify: restart nginx - name: copy TLS certificate copy: src=files/nginx.crt dest={{ cert_file }} notify: restart nginx - name: copy nginx config file copy: src=files/nginx.conf.j2 dest={{ conf_file }} notify: restart nginx - name: enable configuration file: dest=/etc/nginx/sites-enabled/default src={{ conf_file }} state=link notify: restart nginx - name: copy index.html template: src=templates/index.html.j2 dest=/usr/share/nginx/html/index.html mode=0644 handlers: - name: restart nginx service: name=nginx state=restarted 内部变量 ansible_managed : 和模板文件生成时间相关的信息. inventory 文件使用 .ini 格式, 默认为 hosts 文件. [webservers] testserver ansible_ssh_host=127.0.0.1 ansible_ssh_port=22 YAML 文件格式 文件开始. --- 如果没有---标记, 也不影响 ansible 的运行. 注释: # 字符串 : 即使字符串中有空格, 也无需使用引号. 布尔型 : 有多种, 推荐使用 True/False 列表: 使用-作为分隔符 标准列表 - My Fair Lady - Oklahoma - The Pirates of Penzance 内联式列表 [My Fair Lady, Oklahoma, The Pirates of Penzance] 字典: 标准字典 name: tom age: 12 job: manager 内联式字典 {name: tom, age: 12, job: manager} 折行: 使用大于号(&gt;)表示折行]]></content>
      <categories>
        <category>DevOps</category>
      </categories>
      <tags>
        <tag>ansible</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Ansible-配置文件.md]]></title>
    <url>%2F2018%2F03%2F15%2FAnsible-%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[Ansible 配置文件 ansible.cfg 参数总结. #ansible.cfg 有 defaults, ssh_connection,paramiko,accelerate四个配置段. 1. defaults 段 配置名称 环境变量 默认值 hostfile ANSIBLE_HOSTS /etc/ansible/hosts library ANSIBLE_LIBRARY (none) roles_path ANSIBLE_ROLES_PATH /etc/ansible/roles remote_tmp ANSIBLE_REMOTE_TEMP $HOME/.ansible/tmp module_name (none) command pattern (none) * forks ANSIBLE_FORKS 5 module_args ANSIBLE_MODULE_ARGS (empty string) module_lang ANSIBLE_MODULE_LANG en_US.UTF-8 timeout ANSIBLE_TIMEOUT 10 poll_interval ANSIBLE_POLL_INTERVAL 15 remote_user ANSIBLE_REMOTE_USER current user ask_pass ANSIBLE_ASK_PASS false private_key_file ANSIBLE_PRIVATE_KEY_FILE (none) sudo_user ANSIBLE_SUDO_USER root ask_sudo_pass ANSIBLE_ASK_SUDO_PASS false remote_port ANSIBLE_REMOTE_PORT (none) ask_vault_pass ANSIBLE_ASK_VAULT_PASS false vault_password_file ANSIBLE_VAULT_PASSWORD_FILE (none) ansible_managed (none) Ansible managed: { file} modi ed on %Y-%m-%d %H:%M:%S by {uid} on {host} syslog_facility ANSIBLE_SYSLOG_FACILITY LOG_USER keep_remote_ les ANSIBLE_KEEP_REMOTE_FILES true sudo ANSIBLE_SUDO false sudo_exe ANSIBLE_SUDO_EXE sudo sudo_flags ANSIBLE_SUDO_FLAGS -H hash_behaviour ANSIBLE_HASH_BEHAVIOUR replace jinja2_extensions ANSIBLE_JINJA2_EXTENSIONS (none) su_exe ANSIBLE_SU_EXE su su ANSIBLE_SU false su_flags ANSIBLE_SU_FLAGS (empty string) su_user ANSIBLE_SU_USER root ask_su_pass ANSIBLE_ASK_SU_PASS false gathering ANSIBLE_GATHERING implicit action_plugins ANSIBLE_ACTION_PLUGINS /usr/share/ansible_plugins/action_plugins cache_plugins ANSIBLE_CACHE_PLUGINS /usr/share/ansible_plugins/cache_plugins callback_plugins ANSIBLE_CALLBACK_PLUGINS /usr/share/ansible_plugins/callback_plugins connection_plugins ANSIBLE_CONNECTION_PLUGINS /usr/share/ansible_plugins/connection_plugins lookup_plugins ANSIBLE_LOOKUP_PLUGINS /usr/share/ansible_plugins/lookup_plugins vars_plugins ANSIBLE_VARS_PLUGINS /usr/share/ansible_plugins/vars_plugins filter_plugins ANSIBLE_FILTER_PLUGINS /usr/share/ansible_plugins/ lter_plugins log_path ANSIBLE_LOG_PATH (empty string) fact_caching ANSIBLE_CACHE_PLUGIN memory fact_caching_connection ANSIBLE_CACHE_PLUGIN_CONNECTION (none) fact_caching_prefix ANSIBLE_CACHE_PLUGIN_PREFIX ansible_facts fact_caching_timeout ANSIBLE_CACHE_PLUGIN_TIMEOUT 86400 (seconds) force_color ANSIBLE_FORCE_COLOR (none) nocolor ANSIBLE_NOCOLOR (none) nocows ANSIBLE_NOCOWS (none) display_skipped_hosts DISPLAY_SKIPPED_HOSTS true error_on_unde ned_vars ANSIBLE_ERROR_ON_UNDEFINED_VARS true host_key_checking ANSIBLE_HOST_KEY_CHECKING true system_warnings ANSIBLE_SYSTEM_WARNINGS true deprecation_warnings ANSIBLE_DEPRECATION_WARNINGS true callable_whitelist ANSIBLE_CALLABLE_WHITELIST (empty list) command_warnings ANSIBLE_COMMAND_WARNINGS false bin_ansible_callbacks ANSIBLE_LOAD_CALLBACK_PLUGINS false 2. ssh_connection 段 配置名称 环境变量 默认值 ssh_args ANSIBLE_SSH_ARGS -o ControlMaster=auto -o ControlPersist=60s -o ControlPath=&quot;$ANSIBLE_SSH_CONTROL_PATH” control_path ANSIBLE_SSH_CONTROL_PATH %(directory)s/ansible-ssh-%%h-%%p-%%r pipelining ANSIBLE_SSH_PIPELINING false scp_if_ssh ANSIBLE_SCP_IF_SSH false 3. paramiko 段 配置名称 环境变量 默认值 record_host_keys ANSIBLE_PARAMIKO_RECORD_HOST_KEYS true pty ANSIBLE_PARAMIKO_PTY true 4. accelerate 段 (不推荐使用)]]></content>
      <categories>
        <category>DevOps</category>
      </categories>
      <tags>
        <tag>ansible</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Ansible-API]]></title>
    <url>%2F2018%2F03%2F15%2FAnsible-API%2F</url>
    <content type="text"><![CDATA[ansible api 开发篇 ansible api Callbacks Inventory Playbook Script]]></content>
      <categories>
        <category>DevOps</category>
      </categories>
      <tags>
        <tag>ansible</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Ansible-模块]]></title>
    <url>%2F2018%2F03%2F15%2FAnsible-%E6%A8%A1%E5%9D%97%2F</url>
    <content type="text"><![CDATA[Ansible 常用模块使用方法 自定义 Ansible 模块 1. 内置模块是由 ansible 包装后, 在主机上执行一系列操作的脚本. 1.1 查看模块帮助$ ansible-doc MOD_NAME 1.2 查找第三方模块$ ansible-galaxy search MOD_NAME 1.3 常用模块apt update_cache=yes 在安装软件之前, 首先更新 repo 缓存. cache_valid_time=3600 上次 repo 缓存的有效时间. upgrade=yes pipAnsible 的 pip 模块支持向 virtualenv 中安装软件包, 并且还支持在没有可用的 virtualenv 时, 自动创建一个. - name: install required python packages pip: name={{ item }} virtualenv={{ venv_path }} with_items: - gunicorn - django - django-compressor 支持 requirements 文件 - name: install required python pkg pip: requirements={{ proj_path }}/{{ reqs_file }} virtualenv={{ venv_path }} Options : chdircd into this directory before running the command [Default: None] editablePass the editable flag for versioning URLs. [Default: True] executableThe explicit executable or a pathname to the executable to be used to run pip for a specific version of Python installed in the system. For example `pip-3.3&apos;, if there are both Python 2.7 and 3.3 installations in the system and you want to run pip for the Python 3.3 installation. It cannot be specified together with the &apos;virtualenv&apos; parameter (added in 2.1). By default, it will take the appropriate version for the python interpreter use by ansible, e.g. pip3 on python 3, and pip2 or pip on python 2. [Default: None] extra_argsExtra arguments passed to pip. [Default: None] nameThe name of a Python library to install or the url of the remote package. As of 2.2 you can supply a list of names. [Default: None] requirementsThe path to a pip requirements file, which should be local to the remote system. File can be specified as a relative path if using the chdir option. [Default: None] stateThe state of module The &apos;forcereinstall&apos; option is only available in Ansible 2.1 and above. (Choices: present, absent, latest, forcereinstall)[Default: present] umaskThe system umask to apply before installing the pip package. This is useful, for example, when installing on systems that have a very restrictive umask by default (e.g., 0077) and you want to pip install packages which are to be used by all users. Note that this requires you to specify desired umask mode in octal, with a leading 0 (e.g., 0077). [Default: None] versionThe version number to install of the Python library specified in the `name&apos; parameter [Default: None] virtualenvAn optional path to a `virtualenv&apos; directory to install into. It cannot be specified together with the &apos;executable&apos; parameter (added in 2.1). If the virtualenv does not exist, it will be created before installing packages. The optional virtualenv_site_packages, virtualenv_command, and virtualenv_python options affect the creation of the virtualenv. [Default: None] virtualenv_commandThe command or a pathname to the command to create the virtual environment with. For example `pyvenv&apos;, `virtualenv&apos;, `virtualenv2&apos;, `~/bin/virtualenv&apos;, `/usr/local/bin/virtualenv&apos;. [Default: virtualenv] virtualenv_pythonThe Python executable used for creating the virtual environment. For example `python3.5&apos;, `python2.7&apos;. When not specified, the Python version used to run the ansible module is used. [Default: None] virtualenv_site_packagesWhether the virtual environment will inherit packages from the global site-packages directory. Note that if this setting is changed on an already existing virtual environment it will not have any effect, the environment must be deleted and newly created. (Choices: yes, no)[Default: no] copyfileservicetemplatesetup实现 fact 收集的模块. 一般无需再 playbook 中调用该模块, Ansible 会在采集 fact 时, 自动调用. $ ansible server_name -m setup -a &#39;filter=ansible_eth*&#39; 其返回值为一个字典, 字典的 key 是 ansible_fact, 他的 value 是一个有实际 fact 的名字与值组成的字典. setup 模块支持 filter 参数, 可以实现 shell 通配符的匹配过滤. - name: gather facts setup: set_fact使用 set_fact 模块在 task 中设置 fact(与定义一个新变量是一样的). 可以在 register 关键字后, 立即使用 set_fact , 这样使得变量引用更简单. - name: get snapshot id shell: &gt; aws ec2 describe-snapshot --filters Name=tag:Name, Valuse=my-snapshot | jq --raw-outpuy &quot;.Snapshots[].SnapshtId&quot; register: snap_result - set_fact: snap={{ snap_result.stdout }} - name: delete old snapshot command: aws ec2 delete-snapshot --snapshot-id &quot;{{ snap }}&quot; command在 command 中保持幂等性的方法: 指定 creates 参数. # 当 Vagrantfile 存在, 则表示已经处于正确状态, 而且不需要再次执行命令, 从而实现幂等性. - name: create a vagrantfile command: vagrant init {{ box }} creates=Vagrantfile 官方文档: - creates a filename or (since 2.0) glob pattern, when it already exists, this step will *not* be run. [Default: None] - removes a filename or (since 2.0) glob pattern, when it does not exist, this step will *not* be run. [Default: None] script实现幂等性方法: creates 和 removes 参数. 官方文档: - creates a filename, when it already exists, this step will *not* be run. [Default: None] - removes a filename, when it does not exist, this step will *not* be run. [Default: None] debug&gt; DEBUG (/opt/virtualEnv/ansibleEnv/lib/python2.7/site-packages/ansible/modules/utilities/logic/debug.py) This module prints statements during execution and can be useful for debugging variables or expressions without necessarily halting the playbook. Useful for debugging together with the &apos;when:&apos; directive. * note: This module has a corresponding action plugin. Options (= is mandatory): - msg The customized message that is printed. If omitted, prints a generic message. [Default: Hello world!] - var A variable name to debug. Mutually exclusive with the &apos;msg&apos; option. [Default: (null)] - verbosity A number that controls when the debug is run, if you set to 3 it will only run debug when -vvv or above [Default: 0] EXAMPLES: # Example that prints the loopback address and gateway for each host - debug: msg: &quot;System {{ inventory_hostname }} has uuid {{ ansible_product_uuid }}&quot; - debug: msg: &quot;System {{ inventory_hostname }} has gateway {{ ansible_default_ipv4.gateway }}&quot; when: ansible_default_ipv4.gateway is defined - shell: /usr/bin/uptime register: result - debug: var: result verbosity: 2 - name: Display all variables/facts known for a host debug: var: hostvars[inventory_hostname] verbosity: 4 postgresql_userpostgresql_dbdjango_managecron :# 安装 cron job, 注意 name 参数, 该参数必须要有, 该参数将用于删除计划任务时所使用的名称. - name: install poll twitter cron job cron: name=&quot;Poll twitter&quot; minute=&quot;*/5&quot; user={{ user }} job=&quot;{{ manage }} poll_twitter&quot; # 删除计划任务, 基于 name 参数, 在删除时, 会连带注释一起删掉. - name: remote cron job cron: name=&quot;Poll twitter&quot; state=absent git :- name: check out the repository on the host git: repo={{ repo_url }} dest={{ proj_path }} accept_host_key=yes wait_for:You can wait for a set amount of time `timeout’, this is the default if nothing is specified. Waiting for a port to become available is useful for when services are not immediately available after their init scripts return which is true of certain Java application servers. It is also useful when starting guests with the [virt] module and needing to pause until they are ready. This module can also be used to wait for a regex match a string to be present in a file. In 1.6 and later, this module can also be used to wait for a file to be available or absent on the filesystem. In 1.8 and later, this module can also be used to wait for active connections to be closed before continuing,useful if a node is being rotated out of a load balancer pool. Options: active_connection_statesThe list of tcp connection states which are counted as active connections [Default: [u&apos;ESTABLISHED&apos;, u&apos;SYN_SENT&apos;, u&apos;SYN_RECV&apos;, u&apos;FIN_WAIT1&apos;, u&apos;FIN_WAIT2&apos;, u&apos;TIME_WAIT&apos;]] connect_timeoutmaximum number of seconds to wait for a connection to happen before closing and retrying [Default: 5] delaynumber of seconds to wait before starting to poll [Default: 0] exclude_hostslist of hosts or IPs to ignore when looking for active TCP connections for `drained&apos; state [Default: None] hostA resolvable hostname or IP address to wait for [Default: 127.0.0.1] pathpath to a file on the filesytem that must exist before continuing [Default: None] portport number to poll [Default: None] search_regexCan be used to match a string in either a file or a socket connection. Defaults to a multiline regex. [Default: None] sleepNumber of seconds to sleep between checks, before 2.3 this was hardcoded to 1 second. [Default: 1] stateeither `present&apos;, `started&apos;, or `stopped&apos;, `absent&apos;, or `drained&apos; When checking a port `started&apos; will ensure the port is open, `stopped&apos; will check that it is closed, `drained&apos; will check for active connections When checking for a file or a search string `present&apos; or `started&apos; will ensure that the file or string is present before continuing, `absent&apos; will check that file is absent or removed (Choices: present, started, stopped, absent, drained)[Default: started] timeoutmaximum number of seconds to wait for [Default: 300] wait_for_connection : 默认超时时间 600s Waits until remote system is reachable/usable 等待目标主机可以成为 reachable/usable 状态, 即 ssh 22 端口可以连通. - name: Wait 300 seconds, but only start checking after 60 seconds wait_for_connection: delay: 60 # 等待 60s 之后执行 本task timeout: 300 # 超时时间, 默认300s sleep: 2 # 在检查期间, 每次检查之间的间隔时间, 默认为 1s - name: Wait 600 seconds for target connection to become reachable/usable wait_for_connection: wait_for : Waits for a condition before continuing 等待某个主机或端口可用, 适用范围比 wait_for_connection 更加广泛. 可以在本机或目标主机检查其他或本地主机的端口,. - name: Wait 300 seconds for port 22 to become open wait_for: port: 22 sleep: 3 # A resolvable hostname or IP address to wait for. host: &apos;{{ (ansible_ssh_host|default(ansible_host))|default(inventory_hostname) }}&apos; # Can be used to match a string in either a file or a socket connection. search_regex: OpenSSH timeout: 300 # This overrides the normal error message from a failure to meet the required conditions. msg: Timeout to connect through OpenSSH # Either present, started, or stopped, absent, or drained. # When checking a port started will ensure the port is open, stopped will check that it is closed, drained will check for active connections. # When checking for a file or a search string present or started will ensure that the file or string is present before continuing, absent will check that file is absent or removed. state: drained # List of hosts or IPs to ignore when looking for active TCP connections for drained state. exclude_hosts: 10.2.1.2,10.2.1.3 delegate_to: localhost - name: Wait until the process is finished and pid was destroyed wait_for: # Path to a file on the filesystem that must exist before continuing. path: /proc/3466/status state: absent lineinfilestat收集关于文件路径状态的各种信息, 返回一个字典, 该字典包含一个 stat 字段. 部分字段返回值表: 字段 描述 dev inode 所在设备 ID 编号 gid 路径的所属组 ID 编号 inode inode 号 mode 字符串格式的八进制文件模式,如 1777 atime 路径的最后访问时间, 使用 UNIX 时间戳 ctime 路径的创建时间, 使用 UNIX 时间戳, 文件元数据变更时间 mtime 路径的最后修改时间, 使用 UNIX 时间戳 , 文件内容修改时间. nlink 文件硬链接的数量 pw_name 文件所属者的登录名 size 如果是文件, 返回字节单位的文件大小 uid 路径所属者的 uid isblk 如果路径为指定块设备文件, 返回 true ischr 如果路径为指定字符设备文件,返回 true isdir 如果路径为目录, 返回 true isfifo 如果路径为 FIFO(管道), 返回 true isgid 如果文件设置了 setgid , 返回 true isuid 如果文件设置了 setuid , 返回 true islnk 如果文件时符号链接, 返回 true isreg 如果路径是常规文件, 返回 true issock 如果路径是UNIX 域socket, 返回 true rgrp 如果设置所属组可读权限, 返回 true roth 如果设置其他人可读权限, 返回 true rusr 如果设置了属主可读权限, 返回 true wgrp 如果设置所属组可写权限, 返回 true woth 如果设置所属组可写权限, 返回 true wusr 如果设置所属组可写权限, 返回 true xgrp 如果设置所属组可执行权限, 返回 true xoth 如果设置所属组可执行权限, 返回 true xusr 如果设置所属组可执行权限, 返回 true exists 如果存在, 返回 true md5 文件的 md5 值 checksum 文件的hash 值, 可以设置 sha 算法. assertassert 模块在指定的条件不符合是,返回错误, 并失败退出. 主要用于调试.that : 后跟计算表达式msg : 失败后的提示信息. - name: stat /opt/foo stat: path=/opt/foo register: st - name: assert that /opt/foo is a directory assert: that: st.stat.isdir ------- - assert: that: - &quot;my_param &lt;= 100&quot; - &quot;my_param &gt;= 0&quot; msg: &quot;&apos;my_param&apos; must be between 0 and 100&quot; 2. 自定义模块自定义模块存放路径: playbooks/library 2.1 使用 script 自定义 模块2.2 使用 Python 自定义模块.]]></content>
      <categories>
        <category>DevOps</category>
      </categories>
      <tags>
        <tag>ansible</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Ansible-变量.md]]></title>
    <url>%2F2018%2F03%2F15%2FAnsible-%E5%8F%98%E9%87%8F%2F</url>
    <content type="text"><![CDATA[摘要 变量与 fact在 Ansible 中, 变量的作用域是按照主机划分的, 只有针对特定主机讨论变量的值才有意义. 1. 变量1.1. 定义变量vars : 定义变量的列表或字典vars_file : 指定 定义变量的文件列表 vars 区段的定义, 实际上是在 当前 play 中针对一组主机定义了变量, 但 Ansible 实际做法其实时, 对这个群组的每一个主机创建一个变量的副本. ansible 允许定义于主机或群组有关的变量, 这些变量可以定义在 inventory 文件中, 也可以定义在与 inventory 文件放在一起的独立文件中. Ansible 变量定义位置 变量标识 描述 vars playbook 区段, 为字典列表 vars_file playbook 区段, 为指向文件的列表 host_vars 目录, 主机变量 group_vars 目录, 群组变量 主机变量 inventory中, 单独针对主机的变量 群组变量 inventory中, 单独针对单个群组的变量 1.2. 显示变量: debug 模块- debug: var=myvarname 1.3. register 注册变量: 基于 task 的执行结果, 设置变量的值.示例: - name: Run MyProg command: /opt/myprog register: result ignore_errors: True - debug: var=result ignore_errors 语句, 可以实现, 在 task 失败的时候, 是否忽略错误, 继续执行下面的 task, 默认为 False. 访问变量中字典的key, 有两种方式: { { login.stdout } } { { ansible_eth1[&quot;ipv4&quot;][&quot;address&quot;] } } 当 task 在目标主机, 没有执行命令时, 即当目标主机已经符合目标结果时, 输出中没有 stdout,stderr,stdout_lines 三个键值. 如果在 playbook 中使用了注册变量, 那么无论模块是否改变了主机的状态, 请确保你了解变量的内容, 否则, 当你的 playbook 尝试访问注册变量中不存的 key时, 可能会导致失败. 1.4. set_fact 定义新变量使用 set_fact 模块在 task 中设置 fact(与定义一个新变量是一样的). 可以在 register 关键字后, 立即使用 set_fact , 这样使得变量引用更简单. - name: get snapshot id shell: &gt; aws ec2 describe-snapshot --filters Name=tag:Name, Valuse=my-snapshot | jq --raw-outpuy &quot;.Snapshots[].SnapshtId&quot; register: snap_result - set_fact: snap={ { snap_result.stdout } } - name: delete old snapshot command: aws ec2 delete-snapshot --snapshot-id &quot;{ { snap } }&quot; 1.5. 内置变量 参数 说明 hostvars 字典, key 为 Ansible 主机的名字, value 为所有变量名与相应变量值映射组成的字典 inventory_hostname 当前主机被 Ansible 识别的名字, 如果定义了别名, 则为别名. group_names 列表, 由当前主机所属的所有群组组成 groups 字典, key 为 ansible 群组名, value 为群组成员的主机名所组成的列表. 包括 all 分组和 ungrouped 分组 play_hosts 列表, 成员是当前 play 涉及的主机的 inventory 主机名. ansible_version 字典, 由 Ansible 版本信息组成. hostvars : 在 Ansible 中, 变量的作用域是按照主机划分的, 只有针对特定主机讨论变量的值才有意义. 有时候 , 针对一组主机定义的变量, 该变量实际始于特定的主机相关联的. 例如 vars 区段的定义, 实际上是在 当前 play 中针对一组主机定义了变量, 但 Ansible 实际做法其实时, 对这个群组的每一个主机创建一个变量的副本. hostvars变量包含了在所有主机上定义的所有变量, 并以 ansible 识别的主机名作为 key. 如果 Ansible 还未对主机采集 fact, 那么除非启动 fact 缓存, 否则无法使用 hostvars 访问fact. 有时, 在某一个主机上运行的 task 可能会需要在另一台主机上定义的变量. 例如, web 服务器, 可能需要 数据库服务器的 ansible_eth1.ipv4.address 这个 fact. 如果 数据库服务器为 db.example.com, 那么, 其变量引用为: { { hostvars[&apos;db.example.com&apos;].ansible_eth1.ipv4.address } } - debug: var=hostvars[inventory_hostname] : 输出与当前主机相关联的所有变量. groups : 代表当前 inventory 所定义的所有组的集合, 为一个字典. 示例: web 负载均衡配置文件 backend web-backend {% for host in groups.web %} server { { host.inventory_hostname } } { { host.ansible_default_ipv4.address } }:80 {% endfor %} 1.6. 在命令行设置变量向 ansible-playbook 传入 -e var=value 参数设置变量或传递参数, 有最高优先级. 可以覆盖已定义的变量值. $ ansible-playbook example.yml -e token=123456 希望在变量中出现空格, 需要使用引号: $ ansible-playbook playbooks/greeting.yml -e &apos;greeting=&quot;Oops you have another hello world&quot;&apos; `@filename.yml` 传递参数: $ cat greetvars.yml greeting: &quot;ops you have another hello world&quot; $ ansible-playbook playbooks/greeting.yml -e @greetvars.yml 2. fact当 Ansible 采集 fact 的时候, 他会连接到目标主机收集各种详细信息: CPU 架构,操作系统,IP地址,内存信息,磁盘信息等. 这些信息保存在被称为 fact 的变量中. fact 与其他变量的行为一模一样. 2.1. setup 模块实现 fact 收集的模块. 一般无需再 playbook 中调用该模块, Ansible 会在采集 fact 时, 自动调用. `$ ansible server_name -m setup -a &apos;filter=ansible_eth*&apos;` 其返回值为一个字典, 字典的 key 是 ansible_fact, 他的 value 是一个有实际 fact 的名字与值组成的字典. setup 模块支持 filter 参数, 可以实现 shell 通配符的匹配过滤. 2.2. 模块返回 fact如果一个模块返回一个字典且包含名为 ansible_facts 的key, 那么 ansible 将会根据对应的 value 创建响应的变量, 并分配给相对应的主机. 对于返回 fact 的模块, 并不需要使用注册变量, 因为 ansible 会自动创建. 可以自动返回 fact 的模块: $ ansible-doc --list |grep facts - ec2_facts - docker_image_facts 2.3. 本地 fact可将一个或者多个文件放置在目标主机的 /etc/ansible/facts.d/ 目录下, 如果该目录下的文件以 init格式, JSON格式 或者输出JSON格式的可执行文件(无需参数), 以这种形式加载的 fact 是 ansible_local 的特殊变量. 示例: # 目标主机 $ /etc/ansible/facts.d/books.fact [book] title=Ansible: Up and Running author=Lorin Hochstein publisher=P&apos;Reilly Media # ansible 主机 $ cat playbooks/local.yml - name: get local variables hosts: host_c gather_facts: True tasks: - name: print local variables; debug: var=ansible_local - name: print book title debug: msg=&quot;The Book Title is { { ansible_local.books.book.title } }&quot; 注意 ansible_local 变量值的结构, 因为 fact 文件的名称为 books, 所以 ansible_local 变量是一个字典, 且包含一个名为 &quot;books&quot; 的 key. 3. 变量优先级:以下优先级依次降低 命令行参数 其他 通过 inventory 文件或 YAML 文件定义的主机变量或群组变量 Fact 在 role 的 defaults/mail.yml 文件中的变量. 4. 过滤器: 变量加工处理Ansible 除了使用 Jinja2 作为模板之外, 还将其用于变量求值. 即, 可以在 playbook 中在 { {} } 内使用过滤器.除了可以用 Jinja2 的内置过滤器外, Ansible 还有一些自己扩展的过滤器. 有些参数, 需要参数, 有些则不需要. Jinja2 内置过滤器Ansible 过滤器 4.1. default : 设置默认值.# 设置 HOST 变量的默认值, 如果 database 没有被定义, 则使用 localhost . &quot;HOST&quot;: &quot;{ { database | default(&apos;localhost&apos;) } }&quot; 4.2. 用于注册变量的过滤器对注册变量状态检查状态的过滤器 名称 描述 failed 如果注册变量的值是任务 failed , 则返回 True changed 如果注册变量的值是任务 changed , 则返回 True success 如果注册变量的值是任务 success , 则返回 True skipped 如果注册变量的值是任务 skipped , 则返回 True 示例: - name: Run myprog command: /opt/myprog register: result ignore_errors: True - debug: var=result - debug: msg=&quot;Stop Running the playbook if myprog failed&quot; failed_when: result|failed 4.3. 用于文件路径的过滤器用于处理包含控制主机文件系统的路径的变量. 过滤器 描述 basename 文件路径中的目录 dirname 文件路径中的目录 expanduser 将文件路径中的 ~ 替换为用户家目录 realpath 处理符号链接后的文件实际路径 示例: vars: homepages: /usr/share/nginx/html/index.html tasks: - name: copy home page copy: src=files/{ { homepages| basename } } desc={ { homepages } } 4.4. 自定义过滤器Ansible 会在存放 playbook 的目录下的 filter_plugins 目录中寻找自定义过滤器. 也可以放在 /usr/share/ansible_plugins/filter_plugins/ 目录下, 或者 环境变量ANSIBLE_FILTER_PLUGINS 环境变量设置的目录. # filter_plugins/surround_by_quotes.py def surround_by_quote(a_list): return [&apos;&quot;%S&quot;&apos; % an_element for an_element in a_list] class FilterModule(object): def filters(self): return {&apos;surround_by_quote&apos;: surround_by_quote} surround_by_quote 函数定义了 Jinja2 过滤器.FilterModule 类定义了一个 filter 方法, 该方法返回由过滤器名称和函数本身组成的字典. FilterModule 是 Ansible 相关代码, 他使得 Jinja2 过滤器可以再 Ansible 中使用. 5. lookup: 从多种来源读取配置数据.lookup 官方文档说明Ansible 所有的 lookup 插件都是在控制主机, 而不是远程主机上执行的 支持的数据来源表: 名称 描述 file 文件的内容 password 随机生成密码 pipe 本地命令执行的输出 env 环境变量 template Jinja2 模板渲染的结果 csvfile .csv 文件中的条目 dnstxt DNS 的 TXT 记录 redis_ke 对 Redis 的key 进行查询 etcd 对 etcd 中的key 进行查询 file 示例: 在 playbook 中调用 lookup - name: Add my public key as an EC2 key ec2_key: name=mykey key_material=&quot;{ { lookup(&apos;file&apos;, &apos;/home/me/.ssh/id_rsa.pub&apos;) } }&quot; 示例: 使用 Jinja2 模板 # authorized_keys.j2 { { lookup(&apos;file&apos;, &apos;/home/me/.ssh/id_rsa.pub&apos;) } } # playbook - name: copy authorized_host file template: src=authorized_keys.j2 desc=/home/deploy/.ssh/authorized_keys pipe 在控制主机上调用一个外部程序, 并将这个程序的输出打印到标准输出上. 示例: 得到最新的 git commit 使用的 SHA-1 算法的值. - name: get SHA of most recent commit debug: msg=&quot;{ { lookup(&apos;pipe&apos;, &apos;git rev-parse HEAD&apos;) } }&quot; env 获取在控制主机上的某个环境变量的值. 示例: - name: get the current shell debug: msg=&quot;{ { lookup(&apos;env&apos;, &apos;SHELL&apos;) } }&quot; password 随机生成一个密码, 并将这个密码写入到参数指定的(控制主机)文件中. 示例: 生成 deploy 的 Postgre 用户和密码, 并将密码写入到 deploy-password.txt 中: - name: create deploy postgre user postgresql_user: name: deploy password: &quot;{ { lookup(&apos;password&apos;, &apos;deploy-password.txt&apos;) } }&quot; template 指定一个 Jinji2 模板文件, 并返回这个模板渲染的结果. # message.j2 This host runs { { ansible_distribution } } # task - name: output message from template debug: msg=&quot;{ { lookup(&apos;template&apos;, &apos;message.j2&apos;) } }&quot; csvfile 从 csv 文件中读取一个条目. # users.csv username, email lorin, lorin@example.com john, john@example.com sue, sue@example.com # 调用 : 查看名为 users.csv 的文件, 使用逗号作为分隔符来定位区域, 寻找第一列的值是 sue 的那一行, 返回第二列(索引从 0 开始)的值. lookup(&apos;csvfile&apos;, &apos;sue file=users.csv delimiter=, col=1&apos;) --&gt; sue@example.com # 用户名被存储在 username 变量中, 可以用 &quot;+&quot; 连接其他参数, 构建完整的参数字符串. lookup(&apos;csvfile&apos;, username + &apos;file=users.csv delimiter=, col=1&apos;) dnstxt 需要安装 dnspython 包, $ pip install dnspython TXT 记录是 DNS 中一个可以附加在主机名上的任意字符串, 一旦为主机名关联了一条 TXT 记录, 则任何人都可以使用 DNS 客户端获取这段文本. # 使用 dig 查看 TXT 记录 $ dig +short ansiblebook.com TXT &quot;isbn=97801491915325&quot; # task - name: look up TXT record debug: msg=&quot;{ { lookup(&apos;dnstxt&apos;, &apos;ansiblebook.com&apos;) } }&quot; redis-kv 需要安装 redis 包: $ pip install pip 可以使用 redis-kv 获取一个 key 的value, key 必须为字符串. # 设置一个值: $ redis-cli SET weather sunny # task - name: look up value in redis debug: msg=&quot;{ { lookup(&apos;redis_kv&apos;, &apos;redis://localhost:6379,weather&apos;) } }&quot; etcd etcd lookup 默认在 http://127.0.0.1:4001 上查找 etcd 服务器, 可以在执行 ansible-playbook 之前, 通过设置 ANSIBLE_ETCD_URL 改变这个值. # 设置测试值 $ curl -L http://127.0.0.1:4001/v2/keys/weather -XPUT -d value=cloudy # task - name: loop up value in etcd debug: msg=&quot;{ { lookup(&apos;etcd&apos;, &apos;weather&apos;) } }&quot;]]></content>
      <categories>
        <category>DevOps</category>
      </categories>
      <tags>
        <tag>ansible</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Ansible-流程控制.md]]></title>
    <url>%2F2018%2F03%2F15%2FAnsible-%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6%2F</url>
    <content type="text"><![CDATA[Ansible 的流程控制机制, 与使用方法. 假如 ansible 是一门开发语言. 循环 条件 函数 与 role handler 循环迭代 Ansible 总是使用 item 作为 循环迭代变量的名字. 循环结构汇总: 官方文档 | 名称 | 输入 | 循环策略 | | — | — | — | | with_items | 列表 | 对列表元素进行循环 | | with_lines | 要执行的命令 | 对命令输出结果进行逐行循环 | | with_fileglob | glob | 对文件名进行循环 | | with_first_found | 路径的列表 | 输入中第一个存在的文件 | | with_dict | 字典 | 对字典元素进行循环 | | with_flattened | 列表的列表 | 对所有列表的元素顺序循环 | | with_indexed_items | 列表 | 单次迭代 | | with_nested | 列表 | 循环嵌套 | | with_random_choice | 列表 | 单次迭代 | | with_sequence | 参数数组 | 对数组进行循环 | | with_subelements | 字典的列表 | 嵌套循环 | | with_together | 列表的列表 | 对多个列表进行循环 | | with_inventory_hostname | 主机匹配模式 | 对匹配的主机进行循环 | with_items # apt 模块会一次调用整个列表作为参数, 而不是单个调用. # 有些模块支持(调用整个列表), 有些不支持, 如 pip 即是单个调用. - name: install apt packages apt: pkg={{ item }} update_cache=yes cache_valid_time=3600 sudo: True with_items: - git - python-dev - python-pip - supervisor # 另种方式: 传递字典的列表. - name: install python packages pip: name={{ item.name }} version={{ item.version }} virtualenv={{ venv_path }} with_items: - {name: mazzanine, version: 3.1.10} - {name: gunicorn, version: 19.1.1} with_lines 可以在控制主机执行任意命令, 并对命令的输出进行逐行迭代. - name: Send out a slack messag slack: domain: example.slack.com token: &quot;{{ slack_token }}&quot; msg: &quot;{{ item }} was in the list&quot; with_lines: - cat /path/to/mylist.txt with_fileglob 对于迭代控制主机上的一系列文件很有用. - name: add public keys to account authorized_key: user=deploy key=&quot;{{ lookup('file', item) }}&quot; with_fileglob: - /var/keys/*.pub - keys/*.pub with_dict 对字典进行迭代. 当使用该循环结构时, item 循环变量是一个含有如下两个 key 的字典: key: 字典中的一个 key value: 字典中与上面的key 相对应的 value 示例: ansible_eth0.ipv4 { &quot;address&quot;: &quot;10.0.2.15&quot;, &quot;netmask&quot;: &quot;255.255.255.0&quot;, &quot;network&quot;: &quot;10.0.2.0&quot; } task 示例 name: iterate over ansible_eth0debug: msg==with_dict: ansible_eth0.ipv4 条件执行 when: 当 when 表达式返回 True 时, 执行该 Task , 否则跳过该 Task. changed_when &amp; failed_when]]></content>
      <categories>
        <category>DevOps</category>
      </categories>
      <tags>
        <tag>ansible</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Ansible-Inventory.md]]></title>
    <url>%2F2018%2F03%2F15%2FAnsible-Inventory%2F</url>
    <content type="text"><![CDATA[Ansible 静态 Inventory 与 动态 Inventory 配置与使用. inventory : Ansible 可管理主机的集合.1. 静态 Inventory1.1 inventory 行为参数示例 : [targets] localhost ansible_connection=local other1.example.com ansible_connection=ssh ansible_ssh_user=mpdehaan ansible_ssh_pass=123456 other2.example.com ansible_connection=ssh ansible_ssh_user=mdehaan ansible_ssh_pass=123456 名称 默认值 说明 ansible_ssh_host 主机的名字 ssh 目的主机的主机名或IP ansible_ssh_port 22 ssh 默认端口号 ansible_ssh_user root ssh 登录使用的用户名 ansible_ssh_pass none ssh 认证使用的密码(这种方式并不安全,我们强烈建议使用 –ask-pass 或 SSH 密钥) ansible_sudo_pass none sudo 密码(这种方式并不安全,我们强烈建议使用 –ask-sudo-pass) ansible_sudo_exe (new in version 1.8) none sudo 命令路径(适用于1.8及以上版本) ansible_connection smart Ansible 使用何种连接模式连接到目标主机 . 与主机的连接类型.比如:local, ssh 或者 paramiko. Ansible 1.2 以前默认使用 paramiko. 1.2 以后默认使用 ‘smart’,’smart’ 方式会根据是否支持 ControlPersist, 来判断’ssh’ 方式是否可行. ansible_ssh_private_key_file none SSH 认证使用的私钥 ansible_shell_type sh 命令所使用的 shell, 除了 sh 外, 还支持 csh,fish,powershell ansible_python_interpreter /usr/bin/python 目标主机上的 python 解释器 ansible_*_interperter none 与 ansible_python_interpreter 的工作方式相同,可设定如 ruby 或 perl 的路径…. 1.2 ansible.cfg 设置 Inventory 行为参数默认值可以在 [defaults] 中改变一些行为参数的默认值: inventory 行为参数 ansible.cfg 选项 ansible_ssh_port remote_port ansible_ssh_user remote_user ansible_ssh_private_key_file private_key_file ansible_shell_type, shell 的名称 executable, shell 的绝对路径 1.3 群组 all 群组 ansible 自动定义了一个群组为 `all` 或 `*` , 包括 inventory 中的所有主机. 群组嵌套 [django:children] web mysql 模式匹配的主机 : 正则表达式永远以 ~ 开头 | 匹配行为 | 用法示例 | | — | — | | 所有主机 | all | | 所有主机 | * | | 群组的并集 | dev:staging | | 群组的交集 | dev:&amp;staging | | 排除 | dev:!staging | | 通配符 | *.example.com | | 数字范围 | web[1:20].example.com,web[01:20].example.com | | 字母范围 | web-[a-z].example.com | | 正则表达式 | ~web\d\.example\.(com | | 多种模式匹配组合使用 | hosts: dev:staging:&amp;database:!queue | 限制某些主机执行: -l 或 --limit 只针对限定的主机运行. $ ansible-playbook -l hosts playbook.yml $ ansible-playbook --limit hosts playbook.yml # 使用模式匹配语法 $ ansible-playbook -l &apos;staging:&amp;database&apos; playbook.yml 1.4 主机与群组变量 主机变量, 在 inventory 文件中: a.example.com color=red b.example.com color=green 群组变量, 在 inventory 文件中: [all:vars] ntp_server=ntp.ubuntu.com [prod:vars] db_primary_host=prod.db.com db_primary_port=5432 db_replica_host=rep.db.com db_name=mydb db_user=root db_pass=123456 [staging:vars] ... 主机变量和群组变量: 在各自的文件中 可以为每个主机和群组创建独立的变量文件. ansible 使用 YAML 格式来解析这些变量文件. host_vars 目录 : 主机变量文件 group_vars 目录 : 群组变量文件 ansible 假设这些目录在包含 playbook 的目录下 或者与 inventory 文件相邻的目录下. 键值格式 : # playbooks/group_vars/production db_primary_host: prod.db.com db_primary_port: 5432 db_replica_host: rep.db.com db_name: mydb db_user: root db_pass: 123456 # 访问方法: {{ db_primary_host }} 字典格式 : # playbooks/group_vars/production db: user: root password: 123456 name: mydb primary: host: primary.db.com port: 5432 replica: host: replica.db.com port: 5432 rabbitmq: host: rabbit.example.com port: 6379 # 访问方法 {{ db.primary.host }} 将 group_vars/production/ 定义为目录, 将多个包含变量定义的 YAML 文件存放其中; # group_vars/production/db db: user: root password: 123456 name: mydb primary: host: primary.db.com port: 5432 replica: host: replica.db.com port: 5432 # group_vars/production/rebbitmq rabbitmq: host: rabbit.example.com port: 6379 2. 动态 inventory如果 inventory 文件标记为可执行, 那么 Ansible 会假设这是一个动态 inventory 脚本, 并且会执行他, 而不是读取他的内容. 2.1 动态 inventory 脚本的接口--list : 列出所有群组. 输出为一个 JSON 对象, 该对象名为群组名, 值为主机的名字组成的数组. --host=&lt;host_name&gt; : 输出是一个名为变量名, 值为变量值的 JSON 对象. 包含主机的所有特定变量和行为参数. 2.2 在运行时添加主机或群组: add_host, group_by add_host : 调用方式如下: 当做一个模块使用即可 # 使用方法: add_host name=hostname groups=web,staging myvar=myval` # 示例 - name: add the vagrant hosts to the inventory add_host: name=vagrant ansible_ssh_host=127.0.0.1 ansible_ssh_port=2222 ansible_ssh_user=vagrant add_host 模块添加主机仅在本次 playbook 执行过程中有效, 他并不会修改 inventory 文件. group_by : 是一个 模块. 允许在 playbook 执行的时候, 使用 group_by 模块创建群组, 他可以基于已经为每台主机自动设定好的变量值(fact)来创建群组, Ansible 将这些变量称为 fact. - name: grout hosts by distribution hosts: myhosts gather_facts: True tasks: - name: create groups based on Linux distribution group_by: key={{ ansible_distribution }} - name: do something to CentOS hosts hosts: CentOS tasks: - name: install htop yum: name=htop - name: do something to Ubuntu hosts hosts: Ubuntu tasks: - name: install htop apt: name=htop 2.3 ec2.py &amp; ec2.ini 安装配置 AWS EC2 External Inventory Script ec2.py : 动态 Inventory ec2.ini : Inventory 配置文件. 只支持 Python 2.x 缓存 \$HOME/.ansible/tmp/ansible-ec2.cache \$HOME/.ansible/tmp/ansible-ec2.index 缓存过期时间: ec2.ini [ec2] cache_max_age = 0 # 默认 300s, 当值为 0 时, 为不使用缓存. $ ./ec2.py –refresh-cache # 强制刷新缓存 群组 自动生成的群组: | 类型 | 示例 | ansible 群组名 | | — | — | — | | Instance | i-123456 | i-123456 | | Instance type | c1.medium | type_c1_medium | | Security group | ssh | secutity_group_ssh | | Keypair | foo | key_foo | | Region | us-east-1 | us-east-1 | | Tag | env=staging | tag_env_staging | | Availability zone | us-easr-1b | us-easr-1b | | VPC | vpc-14dd1b70 | vpc_id_vpc-14dd1b70 | | all ec2 instance | N/A | ec2 | 在群组名中只有字母,连字符,下划线是合法的. 动态 Inventory 脚本会自动将其他的字符(如空格)转换成下划线.如 Name=My cool name 变为 tag_Name_my_cool_server. 群组操作 ec2.py 生成的群组, 支持 Ansible 群组的交集,并集等操作. 自动生成的群组与 静态 inventory 结合使用: 假设 ec2.py 生成的群组中有一个从 tag 取名的群组名为 tag_type_web, 则可以在 静态inventory文件中重新定义, 或者组合群组. 必须在 静态 inventory 中定义一个空的名为 tag_type_web 的群组, 如果没有定义, 则ansible 会报错. 示例如下: [web:children] tag_type_web [tag_type_web] 使用方法 # 简单使用方法 $ ansible -i ec2.py -u ubuntu us-east-1 -m ping # 复杂使用方法. $ cp ec2.py /etc/ansible/hosts &amp;&amp; chmod +x /etc/ansible/hosts/ec2.py $ cp ec2.ini /etc/ansible/ec2.ini $ export AWS_ACCESS_KEY_ID=&apos;AK123&apos; $ export AWS_SECRET_ACCESS_KEY=&apos;abc123&apos; # just for test, you should see your entire EC2 inventory across all regions in JSON. $ ./ec2.py --list [ --profile PROFILE ] --profile : manage multple AWS accounts, a profile example : [profile dev] aws_access_key_id = &lt;dev access key&gt; aws_secret_access_key = &lt;dev secret key&gt; [profile prod] aws_access_key_id = &lt;prod access key&gt; aws_secret_access_key = &lt;prod secret key&gt; --profile prod, --profile dev ec2.ini : is configured for all Amazon cloud services, but you can comment out any features that aren’t applicable. including cache control and destination variables. 3. 静态 Inventory 与 动态 Inventory 结合使用配置步骤如下: 将 动态inventory 和 静态inventory 放在同一目录下; 在 ansible.cfg 中将 hostfile 的值, 指向该目录即可.]]></content>
      <categories>
        <category>DevOps</category>
      </categories>
      <tags>
        <tag>ansible</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[自动化测试-Splinter]]></title>
    <url>%2F2018%2F03%2F15%2F%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95-splinter%2F</url>
    <content type="text"><![CDATA[使用 Splinter 做自动化测试.Splinter Doc Splinter是一个使用Python开发的开源Web应用测试工具，它可以帮你实现自动浏览站点和与其进行交互。 Splinter 是一个基于 Selenium, PhantomJS, zope.testbrowser 等已存在浏览器的抽象层度较高的自动化测试工具. 1. 特点 API 简单 多浏览器支持, 支持的 浏览器列表如下: chrome webdriver, firefox webdriver, phantomjs webdriver, zopetestbrowser, remote webdriver 支持 CSS 选择器和 Xpath 选择器 支持 iframe 和 alert 支持执行 JavaScript 支持 ajax 调用和 async JavaScript 2. 入门2.1 安装 安装 python 支持 Python 2.7+ 版本 安装 splinter $ pip install splinter 安装浏览器驱动: 以 chrome 为例: https://chromedriver.storage.googleapis.com/index.html?path=2.35/ 2.2 示例:from splinter import Browser # 初始化 browser browser = Browser() # 打开首页 browser.visit(&apos;http://google.com&apos;) browser.fill(&apos;q&apos;, &apos;splinter - python acceptance testing for web applications&apos;) browser.find_by_name(&apos;btnG&apos;).click() if browser.is_text_present(&apos;splinter.readthedocs.io&apos;): print &quot;Yes, the official website was found!&quot; else: print &quot;No, it wasn&apos;t found... We need to improve our SEO techniques&quot; browser.quit() Browser 对象支持 上下文管理: with Browser() as browser: # code here 3. 基础浏览器行为和交互3.1 网页对象 Browser 对象初始化 browser = Browser(&apos;chrome&apos;) browser = Browser(&apos;firefox&apos;) browser = Browser(&apos;zope.testbrowser&apos;) browser = Browser(driver_name=&quot;chrome&quot;, executable_path=&quot;/path/to/chrome&quot;, user_agent=&quot;Mozilla/5.0 (iPhone; U; CPU like Mac OS X; en)&quot;, incognito=True) 浏览网页 browser.visit(&apos;http://cobrateam.info&apos;) browser.visit(&apos;http://username:password@cobrateam.info/protected&apos;) # basic HTTP 认证 重载网页 browser.reload() You can back and forward on your browsing history using back and forward methods: browser.visit(&apos;http://cobrateam.info&apos;) browser.visit(&apos;https://splinter.readthedocs.io&apos;) browser.back() browser.forward() 获取当前网页的相关内容 browser.title # 网页标题 browser.html # 网页的 html 代码 browser.url # 网页的 url 管理多个窗口, 使用 windows 对象, 例如弹出窗口. browser.windows # all open windows browser.windows[0] # the first window browser.windows[window_name] # the window_name window browser.windows.current # the current window browser.windows.current = browser.windows[3] # set current window to window 3 window = browser.windows[0] window.is_current # boolean - whether window is current active window window.is_current = True # set this window to be current window window.next # the next window window.prev # the previous window window.close() # close this window window.close_others() # close all windows except this one 3.2 查找网页元素 网页元素获取 splinter 支持 6 种元素查找方式, 每种方式均返回列表作为查找结果. 支持 first, last 快捷方式, 查找第一个和最后一个元素. 因为每个页面中, id 的值一般是不重复的, 因此 find_by_id 总是返回只有一个元素的列表. browser.find_by_css(&apos;h1&apos;) browser.find_by_xpath(&apos;//h1&apos;) browser.find_by_tag(&apos;h1&apos;) browser.find_by_name(&apos;name&apos;) browser.find_by_text(&apos;Hello World!&apos;) browser.find_by_id(&apos;firstheader&apos;) browser.find_by_value(&apos;query&apos;) browser.find_by_xpath(&apos;//h1&apos;).first browser.find_by_name(&apos;name&apos;).last browser.find_by_tag(&apos;h1&apos;)[1] 获取元素的值 browser.find_by_css(&apos;h1&apos;).first.value 查找 URL 返回列表作为结果. links_found = browser.find_link_by_text(&apos;Link for Example.com&apos;) links_found = browser.find_link_by_partial_text(&apos;for Example&apos;) links_found = browser.find_link_by_href(&apos;http://example.com&apos;) links_found = browser.find_link_by_partial_href(&apos;example&apos;) Clicking links : These methods return the first element always. # 绝对 url browser.click_link_by_href(&apos;http://www.the_site.com/my_link&apos;) # 相对 url browser.click_link_by_partial_href(&apos;my_link&apos;) browser.click_link_by_text(&apos;my link&apos;) browser.click_link_by_partial_text(&apos;part of link text&apos;) browser.click_link_by_id(&apos;link_id&apos;) 链式查找 Finding method are chainable, so you can find the descendants of a previously found element. divs = browser.find_by_tag(&quot;div&quot;) within_elements = divs.first.find_by_name(&quot;name&quot;) ElementDoesNotExist 异常 If an element is not found, the find_* methods return an empty list. But if you try to access an element in this list, the method will raise the splinter.exceptions.ElementDoesNotExist exception. Clicking buttons You can click in buttons. Splinter follows any redirects, and submits forms associated with buttons. browser.find_by_name(&apos;send&apos;).first.click() browser.find_link_by_text(&apos;my link&apos;).first.click() 表单 browser.fill(&apos;query&apos;, &apos;my name&apos;) browser.attach_file(&apos;file&apos;, &apos;/path/to/file/somefile.jpg&apos;) browser.choose(&apos;some-radio&apos;, &apos;radio-value&apos;) browser.check(&apos;some-check&apos;) browser.uncheck(&apos;some-check&apos;) browser.select(&apos;uf&apos;, &apos;rj&apos;) To trigger JavaScript events, like KeyDown or KeyUp, you can use the type method. browser.type(&quot;type&quot;, &quot;typing text&quot;) If you pass the argument slowly=True to the type method you can interact with the page on every key pressed. Useful for test field’s autocompletion (The browser will wait until next iteration to type the subsequent key). for key in browser.type(&quot;type&quot;, &quot;typing slowly&quot;, slowly=True): pass You can also use type and fill methods in an element. browser.find_by_name(&quot;name&quot;).type(&quot;Steve Jobs&quot;, slowly=True) browser.find_by_css(&quot;.city&quot;).fill(&quot;San Francisco&quot;) 判断元素是否可见. # 返回布尔值 browser.find_by_css(&apos;h1&apos;).first.visible 判断元素是否有 className # 返回布尔值 browser.find_by_css(&apos;.content&apos;).first.has_class(&apos;content&apos;) Interacting with elements through a ElementList object You can invoke any Element method on ElementList and it will be proxied to the first element of the list. So the two lines below are quivalent. assert browser.find_by_css(&apos;a.banner&apos;).first.visible assert browser.find_by_css(&apos;a.banner&apos;).visible 3.3 鼠标大多数鼠标事件目前只支持 Chrome 和 Firefox 27.0.1 支持 mouse_over, mouse_out,单击, 双击, 右击鼠标. mouse_over : puts the mouse above the element. browser.find_by_tag(&apos;h1&apos;).mouse_over() mouns_out : puts the mouse out of the element. browser.find_by_tag(&apos;h1&apos;).mouse_out() click : 单击 browser.find_by_tag(&apos;h1&apos;).click() double_click : 双击 browser.find_by_tag(&apos;h1&apos;).double_click() right_click : 右击 browser.find_by_tag(&apos;h1&apos;).right_click() drag_and_drop : You can drag an element and drop it to another element. The example below drags the &lt;h1&gt; ... &lt;/h1&gt; element and drop it to a container element (identified by a CSS class). draggable = browser.find_by_tag(&apos;h1&apos;) target = browser.find_by_css(&apos;.container&apos;) draggable.drag_and_drop(target) 3.4 Ajax &amp; Async JavaScriptWhen working with Ajax and Asynchronous JavaScript, it’s common to have elements which are not present in the HTML code(they are created with JavaScript, dynamically). In this case, you can use the methods is_element_present and is_text_present to check the existence of an element or text – Splinter will load the HTML and JavaScript in the browser and the check will be performed before processing JavaScript. There is also the optional argument wait_time (given in seconds), it’s a timeout: if the verification method gets True it will return the result (even if the wait_time is not over); if it doesn’t get True, the method will wait until the wait_time is over (sp it’ll return the result). # 检查文本是否 存在 browser = Browser() browser.visit(&apos;https://splinter.readthedocs.io/&apos;) browser.is_text_present(&apos;splinter&apos;) # True browser.is_text_present(&apos;splinter&apos;, wait_time=10) # True, using wait_time browser.is_text_present(&apos;text not present&apos;) # False # 检查文本是否 不存在 browser.is_text_not_present(&apos;text not present&apos;) # True browser.is_text_not_present(&apos;text not present&apos;, wait_time=10) # True, using wait_time browser.is_text_not_present(&apos;splinter&apos;) # False 元素(element)存在性检查, 返回布尔值. # 检查元素是否 存在 browser.is_element_present_by_css(&apos;h1&apos;) browser.is_element_present_by_xpath(&apos;//h1&apos;) browser.is_element_present_by_tag(&apos;h1&apos;) browser.is_element_present_by_name(&apos;name&apos;) browser.is_element_present_by_text(&apos;Hello World!&apos;) browser.is_element_present_by_id(&apos;firstheader&apos;) browser.is_element_present_by_value(&apos;query&apos;) browser.is_element_present_by_value(&apos;query&apos;, wait_time=10) # using wait_time # 检查元素是否 不存在 browser.is_element_not_present_by_css(&apos;h6&apos;) browser.is_element_not_present_by_xpath(&apos;//h6&apos;) browser.is_element_not_present_by_tag(&apos;h6&apos;) browser.is_element_not_present_by_name(&apos;unexisting-name&apos;) browser.is_element_not_present_by_text(&apos;Not here :(&apos;) browser.is_element_not_present_by_id(&apos;unexisting-header&apos;) browser.is_element_not_present_by_id(&apos;unexisting-header&apos;, wait_time=10) # using wait_time 3.5 cookie 管理It is possible to manipulate cookies using the cookies attribute from a Browser instance. The cookies attribute is a instance of a CookieManager class that manipulates cookies, like adding and deleting them. 添加 cookies browser.cookies.add({&quot;key&quot;: &quot;value&quot;}) 检索 cookies browser.cookies.all() 删除 cookies 删除 单个 cookies browser.cookies.delete(&quot;key1&quot;) # 删除 单个 cookies browser.cookies.delete(&quot;key1&quot;, &quot;key2&quot;) # 删除 两个 cookies 删除 所有 cookies browser.cookies.delete() 4. JavaScript 支持You can easily execute JavaScript in drivers which support it. browser.execute_script(&quot;$(&apos;body&apos;).empty()&quot;) You can return the result of the script. browser.evaluate_script(&quot;4+4&quot;) == 8 5. 其他5.1 HTTP 响应码处理及异常处理status_code and this HTTP exception handling is available only for selenium webdriver browser.visit(&quot;http://www.baidu.com&quot;) browser.status_code.is_success() # True browser.status_code == 200 # True browser.status_code.code # 200 当网页返回失败时, 触发 HttpResponseError 错误. try: browser.visit(&apos;http://cobrateam.info/i-want-cookies&apos;) except HttpResponseError, e: print &quot;Oops, I failed with the status code %s and reason %s&quot; % (e.status_code, e.reason) 5.2 iframersYou can use the get_iframe method and the with statement to interact with iframe. You can pass the iframe’s name, id, or index to get_iframe. with browser.get_iframe(&apos;iframemodal&apos;) as iframe: iframe.do_stuff() 5.3 alert and promptsOnly webdrivers (Firefox and Chrome) has support for alerts and prompts You can deal with alerts and prompts using the get_alert method. alert = browser.get_alert() alert.text alert.accept() alert.dismiss() In case of prompts, you can answer it using the fill_with method. prompts = browser.get_alert() prompts.text prompts.fill_with(&quot;text&quot;) prompts.accept() prompts.dismiss() You can use the with statement to interacte with both alerts and prompts too. with browser.get_alert() as alert: alert.do_stuff() IMPORTANT : if there’s not any prompt or alert, get_alert will return None. Remember to always use at least one of the alert/prompt ending methods(accept/dismiss). Otherwise your browser instance will be frozen until you accept or dismiss the alert/prompt correctly. 6. Drivers6.1 Chrome 安装 # 依赖 Selenium $ pip install selenium # 需要安装 chrome 浏览器 使用 headless option for Chrome browser = Browser(&quot;chrome&quot;, headless=True) incognito option: 隐身模式 browser = Browser(&quot;chrome&quot;, incognito=True) emulation option: 仿真模式 from selenium import webdriver from splinter import Browser mobile_enulation = {&quot;driverName&quot;: &quot;Google Nexus 5&quot;} chrome_options = webdriver.ChromeOptions() chrome_options.add_experimental_option(&quot;mobileEmulation&quot;, mobile_enulation) browser = Browser(&quot;chrome&quot;, options=chrome_options) screenshot: Take a screenshot of the current page and saves it locally. screenshot(name=None, suffix=&apos;.png&apos;)]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>自动化测试</tag>
        <tag>Splinter</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[fake-useragent-文档]]></title>
    <url>%2F2018%2F03%2F15%2Ffake-useragent-%E6%96%87%E6%A1%A3%2F</url>
    <content type="text"><![CDATA[使用 fake-useragent 为爬虫提供 UserAgent.grabs up to date useragent from useragentstring.comrandomize with real world statistic via w3schools.com https://fake-useragent.herokuapp.com/browsers/0.1.5 1. 安装$ pip install fake-useragent 2. 使用from fake_useragent import UserAgent ua = UserAgent() ua.random # and the best one, random via real world browser usage statistic ua.ie # Mozilla/5.0 (Windows; U; MSIE 9.0; Windows NT 9.0; en-US); ua.msie # Mozilla/5.0 (compatible; MSIE 10.0; Macintosh; Intel Mac OS X 10_7_3; Trident/6.0)&apos; ua[&apos;Internet Explorer&apos;] # Mozilla/5.0 (compatible; MSIE 8.0; Windows NT 6.1; Trident/4.0; GTB7.4; InfoPath.2; SV1; .NET CLR 3.3.69573; WOW64; en-US) ua.opera # Opera/9.80 (X11; Linux i686; U; ru) Presto/2.8.131 Version/11.11 ua.chrome # Mozilla/5.0 (Windows NT 6.1) AppleWebKit/537.2 (KHTML, like Gecko) Chrome/22.0.1216.0 Safari/537.2&apos; ua.google # Mozilla/5.0 (Macintosh; Intel Mac OS X 10_7_4) AppleWebKit/537.13 (KHTML, like Gecko) Chrome/24.0.1290.1 Safari/537.13 ua[&apos;google chrome&apos;] # Mozilla/5.0 (X11; CrOS i686 2268.111.0) AppleWebKit/536.11 (KHTML, like Gecko) Chrome/20.0.1132.57 Safari/536.11 ua.firefox # Mozilla/5.0 (Windows NT 6.2; Win64; x64; rv:16.0.1) Gecko/20121011 Firefox/16.0.1 ua.ff # Mozilla/5.0 (X11; Ubuntu; Linux i686; rv:15.0) Gecko/20100101 Firefox/15.0.1 ua.safari # Mozilla/5.0 (iPad; CPU OS 6_0 like Mac OS X) AppleWebKit/536.26 (KHTML, like Gecko) Version/6.0 Mobile/10A5355d Safari/8536.25 3. update saved database just:from fake_useragent import UserAgent ua = UserAgent() ua.update() Sometimes, useragentstring.com or w3schools.com changes their html, or down, in such case fake-useragent uses hosted cache server heroku.com fallback .If You don’t want to use hosted cache server (version 0.1.5 added) from fake_useragent import UserAgent ua = UserAgent(use_cache_server=False) 4. caech Exceptionfrom fake_useragent import FakeUserAgentError try: ua = UserAgent() except FakeUserAgentError: pass 5. if you use a unknown useragent , it will not raise a error, but return “Your favorite Browser”.import fake_useragent ua = fake_useragent.UserAgent(fallback=&apos;Your favorite Browser&apos;) ua.just_test_agent &apos;Your favorite Browser&apos;]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>爬虫</tag>
        <tag>UserAgent</tag>
        <tag>fake-useragent</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python-装饰器]]></title>
    <url>%2F2018%2F03%2F15%2FPython-%E8%A3%85%E9%A5%B0%E5%99%A8%2F</url>
    <content type="text"><![CDATA[摘要装饰器通常是一个命名的对象(不允许 lambda 表达式), 在被(装饰函数)调用时接受单一参数, 并返回另一个可调用对象. 这里的可调用对象, 不仅仅包含函数和方法, 还包括类. 任何可调用对象(任何实现了 call 方法的对象都是可调用的)都可用作装饰器, 他们返回的对象也不是简单的函数, 而是实现了自己的 call 方法的更复杂的类实例. @some_decorator def decorated_function(): pass # 以上写法总是可以替换为显式的装饰器调用和函数的重新赋值: decorated_function = some_decorator(decorated_function) 1. 装饰器定义/使用方法1.1 通用模式: 作为一个函数def mydecorator(function): def wrapped(*args, **kwargs): # 在函数调用之前, 做点什么 result = function(*args, **kwargs) # 在函数调用之后, 做点什么 # 返回结果 return result # 返回 wrapper 作为装饰函数 return wrapped 1.2 实现 call 方法: 作为一个类非参数化装饰器用作类的通用模式如下: class DecoratorAsClass: def __init__(self, function): self.function = function def __call__(self, *args, **kw): # 在调用原始函数之前, 做点什么 result = self.function(*args, **kwargs) # 在调用原始函数之后, 做点什么 # 返回结果 return result 1.3 参数化装饰器 : 实现第二层包装def repeat(number=3): &quot;&quot;&quot; 多次重复执行装饰函数, 返回最后一次原始函数调用的值作为结果. : param number: 重复次数, 默认值为 3 &quot;&quot;&quot; def actual_decorator(function): def wrapped(*args, **kwargs): result = None for _ in range(number): result = function(*args, **kwargs) return result return wrapped return actual_decorator @repeat(2) def foo(): print(&quot;foo&quot;) 带参数的装饰器总是可以做如下装换: foo = repeat(number=3)(foo) 即使参数化装饰器的参数有默认值, 但名字后面也必须加括号 @repeat() def bar(): print(&quot;bar&quot;) 1.4 保存内省的装饰器使用装饰器的常见缺点是: 使用装饰器时, 不保存函数元数据(主要是文档字符串和原始函数名). 装饰器组合创建了一个新函数, 并返回一个新对象, 完全没有考虑原函数的标志. 这将导致调试装饰器装饰过的函数更加困难, 也会破坏可能用到的大多数自动生产文档的工具, 应为无法访问原始的文档字符串和函数签名. 解决这个问题的方式, 就是使用 functools 模块内置的 wraps() 装饰器. from functools import wraps def preserving_decorator(function): @wraps(function) def wrapped(*args, **kwargs): &quot;&quot;&quot;包装函数内部文档&quot;&quot;&quot; return function(*args, **kwargs) return wrapped @preserving_decorator def function_with_important_docstring(): &quot;&quot;&quot;这是我们想要保存的文档字符串&quot;&quot;&quot; pass print(function_with_important_docstring.__name__) print(function_with_important_docstring.__doc__) 2. 装饰器常用示例2.1 参数检查检查函数接受或返回的参数, 在特定上下文中执行时可能有用. # 装饰器代码 rpc_info = {} # 在实际读取时, 这个类定义会填充 rpc_info 字典, 并用于检查参数类型的特定环境中. def xmlrpc(in_=(), out=(type(None), )): def _xmlrpc(function): # 注册签名 func_name = function.__name__ rpc_info[func_name] = (in_, out) def _check_types(elements, types): &quot;&quot;&quot;用来检查类型的子函数&quot;&quot;&quot; if len(elements) != len(types): raise TypeError(&quot;Argumen count is wrong&quot;) typed = enumerate(zip(elements, types)) for index, couple in typed: arg, of_the_right_type = couple if isinstance(arg, of_the_right_type): continue raise TypeError(&quot;Arg #%d should be %s&quot; % (index, of_the_right_type)) def __xmlrpc(*args): # 没有允许的关键词 # 检查输入的内容 if function.__class__ == &quot;method&quot;: checkable_args = args[1:] # 类方法, 去掉 self else: checkable_args = args[:] # 普通函数 _check_types(checkable_args, in_) # 运行函数 res = function(*args) # 检查输入内容 if not type(res) in (tuple, list): checkable_res = (res, ) else: checkable_res = res _check_types(checkable_res, out) # 函数机器类型检查成功 return res return __xmlrpc return _xmlrpc # 使用示例 class RPCView: @xmlrpc((int, int)) # two int --&gt; None def meth1(self, int1, int2): print(&quot;received %d and %d&quot; % (int1, int2)) @xmlrpc((str, ), (int, )) # string --&gt; int def meth2(self, phrase): print(&quot;received %s&quot; % phrase) return 12 # 调用输出 print(rpc_info) # 输出: # {&apos;meth1&apos;: ((&lt;class &apos;int&apos;&gt;, &lt;class &apos;int&apos;&gt;), (&lt;class &apos;NoneType&apos;&gt;,)), &apos;meth2&apos;: ((&lt;class &apos;str&apos;&gt;,), (&lt;class &apos;int&apos;&gt;,))} my = RPCView() my.meth1(1, 2) # 输出: 类型检查成功 # received 1 and 2 my.meth2(2) # 输出: 类型检查失败 # File &quot;D:\VBoxShare\Work\Documents\PyProject\PyCookbook\test.py&quot;, line 57, in &lt;module&gt; # my.meth2(2) # File &quot;D:\VBoxShare\Work\Documents\PyProject\PyCookbook\test.py&quot;, line 25, in __xmlrpc # _check_types(checkable_args, in_) # File &quot;D:\VBoxShare\Work\Documents\PyProject\PyCookbook\test.py&quot;, line 20, in _check_types # raise TypeError(&quot;Arg #%d should be %s&quot; % (index, of_the_right_type)) # TypeError: Arg #0 should be &lt;class &apos;str&apos;&gt; 2.2 缓存缓存装饰器与参数检查十分相似, 不过他重点是关注那些内容状态不会影响输入的函数, 每组参数都可以链接到唯一的结果. 因此, 缓存装饰器可以将输出与计算法所需的参数放在一起, 并在后续的调用中直接返回他(这种行为成为 memoizing). import time import hashlib import pickle cache = {} def is_obsolete(entry, duration): return time.time() - entry[&quot;time&quot;] &gt; duration def compute_key(function, args, kw): &quot;&quot;&quot; 利用已排序的参数来构建 SHA 哈希键, 并将结果保存在一个全局字典中. 利用 pickle 来建立 hash , 这是冻结所有作为参数传入的对象状态的快捷方式, 以确保所有参数都满足于要求. &quot;&quot;&quot; key = pickle.dumps((function.__name__, args, kw)) return hashlib.sha1(key).hexdigest() def memoize(duration=10): def _memoize(function): def __memoize(*args, **kw): key = compute_key(function, args, kw) # 是否已经拥有它了? if (key in cache and not is_obsolete(cache[key], duration)): print(&quot;We got a winner.&quot;) return cache[key][&quot;value&quot;] # 计算 result = function(*args, **kw) # 保存结果 cache[key] = { &quot;value&quot;: result, &quot;time&quot;: time.time() } return result return __memoize return _memoize @memoize() def func_1(a, b): return a + b print(func_1(2, 2)) # 4 print(func_1(2, 2)) # print , 4 @memoize(1) def func_2(a, b): return a + b print(func_2(2, 2)) # 4 time.sleep(1) print(func_2(2, 2)) # 4 缓存值还可以与函数本身绑定, 以管理其作用域和生命周期, 代替集中化的字典. 但在任何情况下, 更高效的装饰器会使用基于高级缓存算法的专用缓存库. 2.3 代理代理装饰器使用全局代理来标记和注册函数. 例如, 一个根据当前用户来保护代码访问的安全层可以使用集中式检查器和相关的可调用对象要求的权限来实现. class User: def __init__(self, roles): self.roles = roles class Unauthorized(Exception): pass def protect(role): def _protect(function): def __protect(*args, **kw): user = globals().get(&quot;user&quot;) if user is None or role not in user.roles: raise Unauthorized(&quot;I won&apos;t tell you.&quot;) return function(*args, **kw) return __protect return _protect tarek = User((&quot;admin&quot;, &quot;user&quot;)) bill = User((&quot;user&quot;,)) class MySecrets: @protect(&quot;admin&quot;) def waffle_recipe(self): print(&quot;use tons of butter&quot;) these_are = MySecrets() user = tarek these_are.waffle_recipe() # use tons of butter user = bill these_are.waffle_recipe() # __main__.Unauthorized: I won&apos;t tell you. 以上模型常用于 Python Web 框架中(权限验证), 用于定义可发布类的安全性. 例如, Django 提供装饰器来保护函数访问的安全. 2.4 上下文提供者上下文装饰器确保函数可以运行在正确的上下文中, 或者在函数前后运行一些代码, 换句话说, 他设定并复位一个特定的执行环境. 例如, 当一个数据项需要在多个线程之间共享时, 就要用一个锁来保护她避免多次访问, 这个锁可以在装饰器中编写. from threading import RLock lock = RLock() def synchronized(function): def _synchronized(*args, **kw): lock.acquire() try: return function(*args, **kw) finally: lock.release() return _synchronized @synchronized def thread_safe(): # 确保锁定资源 pass 上下装饰器通常会被上下文管理器(with) 替代.]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>python 装饰器</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python-上下文管理]]></title>
    <url>%2F2018%2F03%2F15%2FPython-%E4%B8%8A%E4%B8%8B%E6%96%87%E7%AE%A1%E7%90%86%2F</url>
    <content type="text"><![CDATA[使用上下文协议创建和管理上下文 使用 contextlib.contextmanager 创建和管理上下文 上下文的基本使用和嵌套方法 1. 编写实现上下文管理器1.1 作为一个类: 上下文管理协议任何实现了 上下文管理协议的对象都可以用作上下文管理器. 该协议包含两个特殊方法: __enter__(self) : 调用该方法, 任何返回值都会绑定到指定的 as 语句. __exit__(self, exc_type, exc_value, traceback) : 接受代码块中出现错误时填入的 3 个参数. 如果没有错误, 三个都为 None. 出现错误时, __exit__ 不应该重新引发这个错误, 因为这是调用者(caller) 的责任. 但他可以通过返回 True 来避免引发异常. 多数情况下, 这一方法只是执行一些清理工作, 无论代码块中发生什么, 他都不会返回任何内容. 代码示例: class ContextIllustration: def __enter__(self): print(&quot;entering context&quot;) def __exit__(self, exc_type, exc_value, traceback): print(&quot;leveling context&quot;) if exc_type is None: print(&quot;With no ERROR&quot;) else: print(&quot;With an ERROR (%s)&quot; % exc_value) with ContextIllustration(): print(&quot;inside&quot;) # 输出: # entering context # inside # leveling context # With no ERROR with ContextIllustration(): raise RuntimeError(&quot;Raised within &apos;with&apos;&quot;) # 输出: # entering context # leveling context # With an ERROR (Raised within &apos;with&apos;) # Traceback (most recent call last): # File &quot;D:\VBoxShare\Work\Documents\PyProject\PyCookbook\test.py&quot;, line 23, in &lt;module&gt; # raise RuntimeError(&quot;Raised within &apos;with&apos;&quot;) # RuntimeError: Raised within &apos;with&apos; 通过返回 True 来避免触发异常: class ContextIllustration: def __enter__(self): print(&quot;entering context&quot;) def __exit__(self, exc_type, exc_value, traceback): print(&quot;leveling context&quot;) if exc_type is None: print(&quot;With no ERROR&quot;) else: print(&quot;With an ERROR (%s)&quot; % exc_value) return True with ContextIllustration(): raise RuntimeError(&quot;Raised within &apos;with&apos;&quot;) # 输出: # entering context # leveling context # With an ERROR (Raised within &apos;with&apos;) 1.2 作为一个函数: contextlib 模块标准库 contextlib 提供了与上下文管理器一起使用的辅助函数: contextmanager, 他可以在一个函数里同时提供 __enter__ 和 __exit__ 两部分, 中间用 yield 分开(函数变成了生成器). from contextlib import contextmanager thelist = [1, 2, 3] @contextmanager def ListTransaction(thelist): workingcopy = list(thelist) yield workingcopy # 尽在没有出现错误时才会修改原始列表. thelist[:] = workingcopy with ListTransaction(thelist) as l: print(l) print(type(l)) 传递给 yield 的值, 用作 __enter__() 方法的返回值, 调用 __exit__() 方法时, 执行将在 yield 语句后恢复. 如果上下文中出现异常, 他将以异常形式出现在生成器函数中.如有需要可以捕获异常, 以上例子中, 异常被传递出生成器, 并其他地方进行处理. 如果出现任何异常, 被装饰函数需要再次抛出异常, 以便传递异常 from contextlib import contextmanager @contextmanager def context_illustration(): print(&quot;Entering context&quot;) try: yield except Exception as e: print(&quot;Leaving context&quot;) print(&quot;with an ERROR (%s)&quot; % e) # 抛出异常 raise else: print(&quot;Leaving context&quot;) print(&quot;with no error&quot;) with context_illustration(): print(&quot;Entering&quot;) # 输出: # Entering context # Entering # Leaving context # with no error with context_illustration(): raise RuntimeError(&quot;MyError&quot;) # 输出: # Entering context # Traceback (most recent call last): # File &quot;D:\VBoxShare\Work\Documents\PyProject\PyCookbook\test.py&quot;, line 18, in &lt;module&gt; # Leaving context # with an ERROR (MyError) # raise RuntimeError(&quot;MyError&quot;) # RuntimeError: MyError contextlib 还提供其他三个辅助函数: closing(element) : 返回一个上下文管理器, 在退出时, 调用该元素的 close() 方法, 对处理流的类很有用. supress(*exceptions) : 他会压制发生在 with 语句正文中的特定异常. redirect_stdout(new_target) : 将代码内任何代码的 sys.stdout 输出重定向到类文件(file-like)对象的另一个文件. redirect_stderr(new_target) : 将代码内任何代码的 sys.stderr 输出重定向到类文件(file-like)对象的另一个文件. 2. 使用方式 基本使用 with context_manager: # code here ... 上下文变量: 使用 as 语句保存为局部变量 __enter__() 的任何返回值都会绑定到指定的 as 子句. with context_manager as context: # code here ... 多个上下文管理器(嵌套) with A() as a, B() as b: # code here ... 等价于嵌套使用: with A() as a: with B() as b: # code here ...]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>python 标准库</tag>
        <tag>python 上下文</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PyStdLib-optparse]]></title>
    <url>%2F2018%2F03%2F15%2FPyStdLib-optparse%2F</url>
    <content type="text"><![CDATA[使用 optparse 解析命令行参数. 代码示例: import optparse p = optparse.OptionParser() p.add_option(&quot;-t&quot;, action=&quot;store_true&quot;, dest=&quot;tracing&quot;) p.add_option(&quot;-o&quot;, &quot;--outfile&quot;, action=&quot;store&quot;, type=&quot;string&quot;, dest=&quot;outfile&quot;) p.add_option(&quot;-d&quot;, &quot;--debuglevel&quot;, action=&quot;store&quot;, type=&quot;int&quot;, dest=&quot;debug&quot;) p.add_option(&quot;--speed&quot;, action=&quot;store&quot;, type=&quot;choice&quot;, dest=&quot;speed&quot;, choices=[&quot;slow&quot;, &quot;fast&quot;, &quot;ludicrous&quot;]) p.add_option(&quot;--coord&quot;, action=&quot;store&quot;, type=&quot;int&quot;, dest=&quot;coord&quot;, nargs=2) p.add_option(&quot;--novice&quot;, action=&quot;store_const&quot;, const=&quot;novice&quot;, dest=&quot;mode&quot;) p.add_option(&quot;--guru&quot;, action=&quot;store_const&quot;, const=&quot;guru&quot;, dest=&quot;mode&quot;) p.set_defaults(tracing=False, debug=0, speed=&quot;fast&quot;, coord=(0, 0), mode=&quot;novice&quot;) opt, args = p.parse_args() print &quot;tracing: &quot;, opt.tracing print &quot;outfile: &quot;, opt.outfile print &quot;debug : &quot;, opt.debug print &quot;speed : &quot;, opt.speed print &quot;coord : &quot;, opt.coord print &quot;mode : &quot;, opt.mode print &quot;args : &quot;, args]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>python 标准库</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Django-学习总结]]></title>
    <url>%2F2018%2F03%2F14%2FDjango-%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>web development</tag>
        <tag>django</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Ansible-学习总结]]></title>
    <url>%2F2018%2F03%2F14%2FAnsible-%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[大纲Ansible 原理配置篇 Ansible 简介 Ansible 任务的执行细节原理2.1 角色与依赖:2.2 工作机制2.3 工作原理 安装配置3.1 安装3.2 配置文件 Ansible 抽象实体4.1 inventory4.2 变量与fact4.3 模块4.4 task/play/role/playbook Ansible 命令5.1 ansible5.2 ansible-doc5.3 ansible-galaxy5.4 ansible-vault5.5 ansible-playbook ansible 优化加速6.1 SSH Multiplexing (ControlPersist)6.2 fact 缓存6.3 pipeline6.4 并发 Ansible Inventory篇 静态 Inventory1.1 inventory 行为参数1.2 ansible.cfg 设置 Inventory 行为参数默认值1.3 群组1.4 主机与群组变量 动态 inventory2.1 动态 inventory 脚本的接口2.2 在运行时添加主机或群组: add_host, group_by2.3 ec2.py &amp; ec2.ini 静态 Inventory 与 动态 Inventory 结合使用 Ansible task/play/role篇 task play role Ansible api 开发篇Ansible 番外篇之 ansible.cfg 配置 defaults 段 ssh_connection 段 paramiko 段 accelerate 段 (不推荐使用) Ansible 番外篇之模块 内置模块1.1 查看模块帮助1.2 查找第三方模块1.3 常用模块 自定义模块2.1 使用 script 自定义 模块2.2 使用 Python 自定义模块. Ansible 番外篇之变量与fact 变量1.1. 定义变量1.2. 显示变量: debug 模块1.3. register 注册变量: 基于 task 的执行结果, 设置变量的值.1.4. set_fact 定义新变量1.5. 内置变量1.6. 在命令行设置变量 fact2.1. setup 模块2.2. 模块返回 fact2.3. 本地 fact 变量优先级: 过滤器: 变量加工处理4.1. default : 设置默认值.4.2. 用于注册变量的过滤器4.3. 用于文件路径的过滤器4.4. 自定义过滤器 lookup: 从多种来源读取配置数据. file pipe env password template csvfile dnstxt redis-kv etcd Ansible 番外篇之流程控制假如 ansible 是一门开发语言. 循环 条件 函数 与 role]]></content>
      <categories>
        <category>DevOps</category>
      </categories>
      <tags>
        <tag>ansible</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[AngularJS-学习总结]]></title>
    <url>%2F2018%2F03%2F14%2FAngularJS-%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>AngularJS</tag>
        <tag>JS 前端框架</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python-标准库]]></title>
    <url>%2F2018%2F03%2F14%2Fpython-%E6%A0%87%E5%87%86%E5%BA%93%2F</url>
    <content type="text"><![CDATA[python 标准库]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>python 标准库</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Flask-学习总结]]></title>
    <url>%2F2018%2F03%2F14%2FFlask-%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[Flask 学习总结]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>web development</tag>
        <tag>flask</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Sublime-Text-使用总结]]></title>
    <url>%2F2018%2F03%2F14%2FSublime-Text-%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[初始化配置设置 Linux 换行符Perference-&gt;Setting-*. 设置对象是 default_line_ending, 这个参数有三 个可用选项： - system : system是根据当前系统情况设置, - windows : windows使用的CRLF, - unix : unix使用的是 LF 设置 tab 为 4 个空格.Preference -&gt; Settings-User // The number of spaces a tab is considered equal to &quot;tab_size&quot;: 4, // Set to true to insert spaces when tab is pressed &quot;translate_tabs_to_spaces&quot;: true, 自动保存Preference -&gt; Settings-User &quot;save_on_focus_lost&quot;: true 手动安装插件插件Preference -&gt; Browse Package 把下载的插件解压到打开的文件夹中, 解压后即可. 去除解压后文件夹中的 `-` 等字符, 重启 sublime 即可. install package controllSUBLIME TEXT 3 import urllib.request,os,hashlib; h = &apos;df21e130d211cfc94d9b0905775a7c0f&apos; + &apos;1e3d39e33b79698005270310898eea76&apos;; pf = &apos;Package Control.sublime-package&apos;; ipp = sublime.installed_packages_path(); urllib.request.install_opener( urllib.request.build_opener( urllib.request.ProxyHandler()) ); by = urllib.request.urlopen( &apos;http://packagecontrol.io/&apos; + pf.replace(&apos; &apos;, &apos;%20&apos;)).read(); dh = hashlib.sha256(by).hexdigest(); print(&apos;Error validating download (got %s instead of %s), please try manual install&apos; % (dh, h)) if dh != h else open(os.path.join( ipp, pf), &apos;wb&apos; ).write(by) SUBLIME TEXT 2 import urllib2,os,hashlib; h = &apos;df21e130d211cfc94d9b0905775a7c0f&apos; + &apos;1e3d39e33b79698005270310898eea76&apos;; pf = &apos;Package Control.sublime-package&apos;; ipp = sublime.installed_packages_path(); os.makedirs( ipp ) if not os.path.exists(ipp) else None; urllib2.install_opener( urllib2.build_opener( urllib2.ProxyHandler()) ); by = urllib2.urlopen( &apos;http://packagecontrol.io/&apos; + pf.replace(&apos; &apos;, &apos;%20&apos;)).read(); dh = hashlib.sha256(by).hexdigest(); open( os.path.join( ipp, pf), &apos;wb&apos; ).write(by) if dh == h else None; print(&apos;Error validating download (got %s instead of %s), please try manual install&apos; % (dh, h) if dh != h else &apos;Please restart Sublime Text to finish installation&apos;) 大块方框,Sublime &gt; Preferences &gt; Package Settings &gt; Anaconda &gt; Settings User {&quot;anaconda_linting&quot;: false} 中文输入法光标跟随Packages Control -&gt; install -&gt; IMESupport 常用插件SublimeLinter : 用于高亮提示用户编写的代码中存在的不规范和错误的写法, 支持 JavaScript、CSS、HTML、Java、PHP、Python、Ruby 等十多种开发语言. SideBarEnhancements : SideBarEnhancements是一款很实用的右键菜单增强插件；在安装该插件前, 在Sublime Text左侧FOLDERS栏中点击右键, 只有寥寥几个简单的功能 Javascript-API-Completions : 支持Javascript、JQuery、Twitter Bootstrap框架、HTML5标签属性提示的插件, 是少数支持sublime text 3的后缀提示的插件, HTML5标签提示sublime text3自带, 不过JQuery提示还是很有用处的, 也可设置要提示的语言. Git : Glue : 会在界面下方显示一个小窗口, 你可以在那里写Shell脚本. 这样一来, 你的编辑器就不仅仅局限于使用Git了 GitGutter &amp; Modific : 这些插件可以高亮相对于上次提交有所变动的行, 换句话说是实时的diff工具 GitGutter : 这是一个小巧有用的插件, 它会告诉你自上次git commit以来已经改变的行. 一个指示器显示在行号的旁边. PlainTasks : 杰出的待办事项表！所有的任务都保持在文件中, 所以可以很方便的把任务和项目绑定在一起. 可以创建项目, 贴标签, 设置日期. 有竞争力的用户界面和快捷键. Lua : Python : AllAutocomplete : 搜索全部打开的标签页 Emmet : HTML 快速补全 markdown : anaconda : Python IDE anaconda 不能与 jedi 同时存在, 会出现 左括号无法写入的情况. GBK support : 支持 GBK 编码 SublimeTmpl : 支持文件模板, git 地址. 默认模板支持及快捷键 ctrl+alt+h html ctrl+alt+j javascript ctrl+alt+c css ctrl+alt+p php ctrl+alt+r ruby ctrl+alt+shift+p python 添加自定义模板文件及快捷键 : 参考 https://segmentfault.com/a/1190000008674119 1. 新建并编辑自定义模板文件 Packages\User\SublimeTmpl\templates\hexomd.tmpl --- title: ${saved_filename} date: ${date} categories: tags: --- 摘要 &lt;!-- more --&gt; 正文 2. sublime 模板文件定义 : Commands-User [ { &quot;caption&quot;: &quot;Tmpl: Create Hexo Markdown&quot;, &quot;command&quot;: &quot;sublime_tmpl&quot;, &quot;args&quot;: {&quot;type&quot;: &quot;hexomd&quot;} } ] 3. 快捷键定义 : KeyBing-User [ { &quot;keys&quot;: [&quot;ctrl+alt+m&quot;], &quot;command&quot;: &quot;sublime_tmpl&quot;, &quot;args&quot;: {&quot;type&quot;: &quot;hexomd&quot;}, &quot;context&quot;: [{&quot;key&quot;: &quot;sublime_tmpl.hexomd&quot;}] } ] 4. 用户设置定义 : Settings-User { # 支持 ${saved_filename} 变量 &quot;enable_file_variables_on_save&quot;: true, } 设置快捷键. 在SublimeText里, 打开Preferences -&gt; Key Bindings - User, 我设置的快捷键：[ { &quot;keys&quot;: [&quot;ctrl+f9&quot;], &quot;command&quot;: &quot;build&quot; }, { &quot;keys&quot;: [&quot;f10&quot;], &quot;command&quot;: &quot;build&quot;, &quot;args&quot;: {&quot;variant&quot;: &quot;Run&quot;} }, { &quot;keys&quot;: [&quot;ctrl+shift+x&quot;], &quot;command&quot;: &quot;toggle_comment&quot;, &quot;args&quot;: { &quot;block&quot;: true } }, ]]]></content>
      <categories>
        <category>Tools</category>
      </categories>
      <tags>
        <tag>sublime</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[markdown 语法总结]]></title>
    <url>%2F2018%2F03%2F14%2Fmarkdown-%E8%AF%AD%E6%B3%95%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[区块元素 段落 1. 类 Setext 格式 : 底线 形式 最高阶标题 : ==== 第二阶标题 : ---- 示例 : This is H1 ========== This is H2 ---------- 2. 类 atx 格式 : # 形式 在行首插入 1 - 6 个 # , 对应标题1 - 标题6 示例 : # This is H1 ## This is H2 ### This is H3 ** 可以选择性的 [闭合] 类 atx 样式的标题 : 在行尾加上 # , 而且行尾的 # 数量也无需同开头一样. 区块引用 Blockquotes 普通区块引用 : &gt; &gt; This is a blockquote with two paragraphs. Lorem ipsum dolor sit amet, &gt; consectetuer adipiscing elit. Aliquam hendrerit mi posuere lectus. &gt; Vestibulum enim wisi, viverra nec, fringilla in, laoreet vitae, risus. 嵌套区块引用 : 根据层次加上不同数量的 &gt; &gt; This is a blockquote with two paragraphs. Lorem ipsum dolor sit amet, &gt;&gt; consectetuer adipiscing elit. Aliquam hendrerit mi posuere lectus. &gt;&gt; Vestibulum enim wisi, viverra nec, fringilla in, laoreet vitae, risus. 引用的区域也可以使用其他的 Markdown 语法 : 包括标题,列表,代码区块等. 列表 有序列表 : 数字 + . 无序列表 : * + - , 作用相同, 无差别. ** 层次化表示, 需要缩进. ** 转义 : \ 如 : 1991\.12\.12 代码区块 缩进4个空格 , 或者 1 个制表符. 代码区块会一直持续到没有缩进的那一行, 或是文件结尾. ** 代码区块中, 一般 Markdown 语法不会被转换. 代码 小段代码 `CODE` `` CODE `` ** 多个反引号时, 可以在代码中使用 反引号本身. ** 代码区段的起始和结束端都可以放入一个空白，起始端后面一个，结束端前面一个，这样你就可以在区段的一开始就插入反引号 ** 在代码区段内，&amp; 和尖括号都会被自动地转成 HTML 实体，这使得插入 HTML 原始码变得很容易 分割线 : 三个以上的星号,减号,底线来建立一个分割线, 行内不能有其他东西. 型号或减号之间可以插入空格. *** * * * --- - - - - - 链接 链接文字 : [文字] 行内式 [Name](http://www.baidu.com &quot;Title&quot;) 相对路径 [logo](/static/logo.jpg &quot;logo&quot;) 参考式 : 先定义, 后引用 定义 : 在文档的任意处, 把这个标记的链接内容定义出来： [id]: http://example.com &quot;Optionnal Title&quot; 引用 : 不区分大小写 [Name][id] 示例 : [foo]: http://example.com/ &quot;Optional Title Here&quot; [foo]: http://example.com/ &apos;Optional Title Here&apos; [foo]: http://example.com/ (Optional Title Here) [id]: &lt;http://example.com/&gt; &quot;Optional Title Here&quot; [link text][a] [link text][A] 强调 : *WORDS* : &lt;em&gt; _WORDS_ : &lt;em&gt; **WORD** : &lt;strong&gt; __WORD__ : &lt;strong&gt; \* : 转义 \_ : 转义 ** 如果 * 和 _ 两边都有空白的话，它们就只会被当成普通的符号。 图片 行内式 ![Alt text](/path/to/img.jpg) ![Alt text](/path/to/img.jpg &quot;Optional title&quot;) 参考式 ![Alt text][id] [id]: url/to/image &quot;Optional title attribute&quot; ** Markdown 无法指定图片的 宽高, 如果需要可以使用 &lt;img&gt; 标签. 自动链接 : 针对 URL 和 Email 地址 &lt;http://example.com/&gt; &lt;address@example.com&gt; 反斜杠 : 转义 Markdown 支持一下这些符号前面加上 反斜杠 来帮助插入普通的符号. \ 反斜线 ` 反引号 * 星号 _ 底线 {} 花括号 [] 方括号 () 括弧 # 井字号 + 加号 - 减号 . 英文句点 ! 惊叹号 免费编辑器 Windows 平台 MarkdownPad MarkPad Linux 平台 ReText Mac 平台 Mou 在线编辑器 Markable.in Dillinger.io 浏览器插件 MaDe (Chrome) 高级应用 Sublime Text 2 + MarkdownEditing / 教程]]></content>
      <categories>
        <category>tools</category>
      </categories>
      <tags>
        <tag>markdown</tag>
        <tag>标记语言</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo+nexT 博客建设指南]]></title>
    <url>%2F2018%2F03%2F14%2FHexo-nexT-%E5%8D%9A%E5%AE%A2%E5%BB%BA%E8%AE%BE%E6%8C%87%E5%8D%97%2F</url>
    <content type="text"><![CDATA[Hexo 搭建 Github 博客开始使用安装 git$ yum install git -y 安装 NodeJS$ git clone https://github.com/creationix/nvm.git $ source nvm/nvm.sh $ nvm install stable 设置 Github注册 github创建 github page创建仓库, 仓库的名字要和你的账号对应, 格式为: USERNAME.github.io 安装 hexo-cli$ chmod 755 /root &amp;&amp; mkdir -m 755 -p /root/.npm/_logs $ npm install -g hexo-cli $ chmod 700 /root $ npm install -g hexo-cli 建站安装配置$ hexo init &lt;floder&gt; $ cd &lt;floder&gt; $ npm install 文件件目录结构 . ├── _config.yml # 网站的配置信息, 可以在此配置大部分参数 ├── package.json # 应用程序的信息. EJS, Stylus 和 Markdown renderer 已默认安装，您可以自由移除。 ├── scaffolds # 模板文件夹, 当新建文章时, Hexo 会根据 scaffold 来建立文件. | # Hexo 的模板是指在新建的 markdown 文件中默认填充的内容, 每次新建一篇文章时都会包含这个修改. ├── source # 存放用户资源. 除 _posts 文件夹外, 开头命名为 _ 的文件/文件夹和隐藏的文件都会被忽略. | | # Markdown 和 HTML 文件会被解析并放到 public 文件夹, 而其他文件会被拷贝过去. | ├── _drafts | └── _posts └── themes # 主题文件夹, Hexo 会根据主题来生成静态内容. # 安装 next theme, 可选. $ mkdir themes/next $ curl -s https://api.github.com/repos/iissnan/hexo-theme-next/releases/latest | grep tarball_url | cut -d &apos;&quot;&apos; -f 4 | wget -i - -O- | tar -zx -C themes/next --strip-components=1 # 修改默认 主题设置, 可选 $ vim _config.yml theme: next # 安装 hexo server $ npm install hexo-server --save # 启动 hexo server $ hexo server --ip=0.0.0.0 写文章与提交部署安装 hexo-deployer-git 部署方式 $ npm install hexo-deployer-git --save # 配置部署方式 $ vim _config.yml deploy: type: git repo: https://github.com/pyfdtic/pyfdtic.github.io.git branch: master 写文章 # hexo new &quot;TITLE&quot; $ vim source/_posts/TITLE.md --- title: first post date: 2018-03-14 17:08:36 categories: - test tags: - tag-a - tag-b - tag-c --- # content 写摘要: --- 这里是摘要 &lt;!-- more --&gt; 这是正文 生成静态文件并部署 $ hexo g -d 密钥认证提交 $ vim _config.yml 其中 repo 配置为 ssh 协议地址 # 语言配置 language: zh-Hans $ 在 github 上配置 ssh 密钥. 配置主题文档 $ vim themes/next/_config.yml # 主页预览显示 auto_excerpt: enable: true length: 250 # 选择不同的主体 #scheme: Muse scheme: Mist # 主页设置 menu: home: / || home about: /about/ || user tags: /tags/ || tags categories: /categories/ || th archives: /archives/ || archive tags/categories 页面 # tags $ hexo new page &quot;tags&quot; $ vim source/tags/index.md --- title: Tags date: 2018-03-14 18:09:40 type: &quot;tags&quot; comments: false --- $ vim themes/next/_config.yml menu: # ... tags: /tags/ || tags # ... # categories $ hexo new page &quot;categories&quot; $ vim source/categories/index.md --- title: Tags date: 2018-03-14 18:09:40 type: &quot;categories&quot; comments: false --- $ vim themes/next/_config.yml menu: # ... categories: /categories/ || th # ... about页面 $ hexo new page &quot;about&quot; 谷歌/百度统计 $ vim _config.yml google_analytics: UA-[numbers] baidu_analytics: your-analytics-id 站内搜索: $ npm install hexo-generator-searchdb --save $ vim _config.yml search: path: search.xml field: post format: html limit: 10000 $ vim themes/next/_config.yml local_search: enable: true # if auto, trigger search by changing input # if manual, trigger search by pressing enter key or search button trigger: auto # show top n results per article, show all results by setting to -1 top_n_per_article: -1 站点地图: $ npm install hexo-generator-sitemap $ vim themes/next/_config.yml menu: # ... sitemap: /sitemap.xml || sitemap $ 在 google Search console 提交 siteamp 地图. 配置资源文件夹 $ mkdir source/images # 在文章中引用 ![](/images/image.jpg) 主题配置参考站点配置 # ============================================================================= # NexT Theme configuration # ============================================================================= avatar: https://avatars1.githubusercontent.com/u/32269?v=3&amp;s=460 # Duoshuo duoshuo_shortname: notes-iissnan # Disqus disqus_shortname: # Social links social: GitHub: https://github.com/iissnan Twitter: https://twitter.com/iissnan Weibo: http://weibo.com/iissnan DouBan: http://douban.com/people/iissnan ZhiHu: http://www.zhihu.com/people/iissnan # Creative Commons 4.0 International License. # http://creativecommons.org/ # Available: by | by-nc | by-nc-nd | by-nc-sa | by-nd | by-sa | zero creative_commons: by-nc-sa # Google Webmaster tools verification setting # See: https://www.google.com/webmasters/ google_site_verification: VvyjvVXcJQa0QklHipu6pwm2PJGnnchIqX7s5JbbT_0 # Google Analytics # Google分析ID google_analytics: # 百度分析ID baidu_analytics: 50c15455e37f70aea674ff4a663eef27 # Specify the date when the site was setup since: 2011 # ============================================================================= # End NexT Theme configuration # ============================================================================= 主题配置文件 menu: home: / categories: /categories archives: /archives tags: /tags #about: /about # Place your favicon.ico to /source directory. favicon: /favicon.ico # Set default keywords (Use a comma to separate) keywords: &quot;Hexo,next&quot; # Set rss to false to disable feed link. # Leave rss as empty to use site&apos;s feed link. # Set rss to specific value if you have burned your feed already. rss: # Icon fonts # Place your font into next/source/fonts, specify directory-name and font-name here # Avialable: default | linecons | fifty-shades | feather #icon_font: default #icon_font: fifty-shades #icon_font: feather icon_font: linecons # Code Highlight theme # Available value: normal | night | night eighties | night blue | night bright # https://github.com/chriskempson/tomorrow-theme highlight_theme: normal # MathJax Support mathjax: # Schemes scheme: Mist # Automatically scroll page to section which is under &lt;!-- more --&gt; mark. scroll_to_more: true # Automatically add list number to toc. toc_list_number: true ## DO NOT EDIT THE FOLLOWING SETTINGS ## UNLESS YOU KNOW WHAT YOU ARE DOING # Use velocity to animate everything. use_motion: true # Fancybox fancybox: true # Static files vendors: vendors css: css images: images # Theme version version: 0.4.2 删除文章$ hexo clean $ hexo g -d 配置 _config.yml网站 参数 描述 title 网站标题 subtitle 网站副标题 description 网站描述, 网站 SEO author 作者. 显示文章的作者 language 网站使用的语言 timezone 网站时区. Hexo 默认使用浏览器时区 网址 参数 描述 默认值 url 网址 - root 网站根目录 - permalink 文章的永久链接 :year/:mouth/:day/:title permalink_defaults 永久链接中各部分的默认值 网站存放在子目录, 如果网站存放在子目录中, 如 http://yoursite.com/blog , 则需要把 url 设为 ‘http://yoursite.com/blog&#39;, 并把 root 设为 /blog/; 目录 参数 描述 默认值 source_dir 资源文件夹, 用于存放内容 source public_dir 公共文件夹, 用于存放生成的站点文件 public tag_dir 标签文件夹 tags archive_dir 归档文件夹 archives category_dir 分类文件夹 categories code_dir include code 文件夹 downloads/code i18n_dir 国际化(i18n)文件夹 :lang skip_render 跳过指定文件的渲染, 可使用 glob 表达式来匹配路径 如果刚接触 hexo , 则没必要设置以上各值. 文章 参数 描述 默认值 new_post_name 新文章的文件名称 :title.md default_layout 预设布局 post auto_spacing 在中文和英文之间加入空格 false titlecase 把标题转换为 title case false external_link 在新标签中打开链接 true filename_case 把文件名称转换为 (1) 小写或 (2) 大写 0 render_drafts 显示草稿 false post_asset_folder 启动 Asset 文件夹 false relative_link 把链接改为与根目录的相对位址 false future 显示未来的文章 true highlight 代码块的设置 默认情况下，Hexo生成的超链接都是绝对地址. 建议使用绝对地址. 分类 &amp; 标签 参数 描述 默认值 default_category 默认分类 uncategorized category_map 分类别名 tag_map 标签别名 日期/时间格式Hexo 使用 Moment.js 来解析和显示时间. 参数 描述 默认值 date_format 日期格式 YYYY-MM-DD time_format 时间格式 H:mm:ss 分页 参数 描述 默认值 per_page 每页显示的文章数量(0= 关闭分页功能) 10 pagination_dir 分页目录 page 扩展 参数 描述 默认值 theme 当前主题名称, 值为 false 时禁用主题 deploy 部署部分的设置 指令$ hexo SUB_CMD PARAM init [floder] : 新建一个网站. floder 为空时, 为当前文件夹. new [layout] &lt;title&gt; : 新建一篇文章, 如果没有设置`layout`的话, 默认使用 `_config.yml` 中的 `default_layout` 参数代替. 如果标签包含空格, 请使用引号. generate : 生成静态文件. 可以简写为 &quot;hexo g&quot; --d, --deploy : 文件生成后, 立即部署网站 -w, --watch : 监视文件变动. publish [layout] &lt;filename&gt; : 发表草稿 server : 启动服务器, 默认为 &quot;http://localhost:4000/&quot; -p, --port : 指定端口 -s, --static : 只使用静态文件, -l, --log : 启动日志记录, 使用覆盖记录格式. deploy : 部署网站. 可以简写为 &quot;hexo d&quot; -g, --generate : 部署之前预先生成静态文件. render &lt;file1&gt; [file2] ... : 渲染文件. -o, --output : 设置输出路径. migrate &lt;type&gt; : 从其他博客系统迁移. clean : 清除缓存文件(db.json) 和 已生成的静态文件(public). 在某些情况下(尤其是更换主题后), 如果发现对网站的更改无论如何不生效, 可能需要运行该命令. list &lt;type&gt; : 列出网站资料 version : 显示 hexo 版本 --safe : 在安全模式下运行, 不会载入插件和脚本. 当安装新插件遇到问题时, 可以尝试以安全模式重新执行. --debug : 在终端中显示调试信息, 并记录到 debug.log. --silent : 隐藏终端信息 --config custom.yml : 自定义配置文件路径, 执行后将不再使用 _config.yml --draft : 显示 source/_drafts 文件夹中的草稿万丈. --cwd /path/to/cwd : 自定义当前工作目录. 基本操作写作新建文章新建一篇文章: $ hexo new [layout] &lt;title&gt; 可以在 layout 中指定文章的布局(layout), 默认为 post, 可以通过修改 _config.yml 中的 default_layout 参数来指定默认布局. 文章布局Hexo 有三种默认布局: post, page, draft. 他们分别对应不同的路径, 用户自定义的其他布局和post相同, 都将存储在source/_posts 文件夹. 布局 路径 post source/_posts page source draft source/_drafts 如果你不希望你的文章被处理, 可以将 Front-Matter 中的 layout: 设置为 false 草稿草稿(draft) 默认不会显示在页面中, 可以在执行时加上 --draft 参数, 或是把 render_drafts 参数设置为 true 来预览草稿. draft 为草稿布局, 保存与 source/_drafts 目录, 可以通过 publish 命令将草稿移动到source/_posts 文件夹, publish 与 new 使用方式十分类似. $ hexo publish [layout] &lt;title&gt; 文件名称Hexo 默认以标题作为文件名称, 可以编辑 new_post_name 参数来改变默认的文件名称.如 :year-:month-:day-:title.md. 变量 描述 :title 标题(小写, 空格将被替换为短杠) :year 建立年份, 如 2016 :mouth 建立月份, 前导有零, 如 04 :i_mouth 建立月份, 前导无零, 如 4 :day 建立的日期, 前导有零, 如 07 :i_day 建立的日期, 前导无零, 如 7 模板(scaffold)使用方法在新建文章时, Hexo 会根据 scaffolds 文件夹内向对应的文件来建立新文件. 如: # hexo 在 scaffolds 文件夹中寻找 photo.md , # 并根据其内容建立文章. $ hexo new photo &quot;My Gallery&quot; 模板中的可用变量 变量 描述 layout 布局 title 标题 date 文件建立日期 Front-matter使用格式及预定义参数Front-matter 是文件最上方以 --- 分割的区域, 用于指定个别文件的变量. title: Hello World date: 2013/7/12 20:46:25 --- 预定义参数列表如下: 参数 描述 默认值 layout 布局 title 标题 date 建立日期 文件建立日期 updated 更新日期 文件跟新日期 comments 开启文章评论功能 true tags 标签(不适用于分页) categories 分类(不适用于分页) permalink 覆盖文章网址 分类和标签只有文章支持分类和标签, 可以在 Front-matter 中设置. 分类: 分类有顺序性和层次性, 如 Foo,Bar 不等于 Bar, Foo 标签: 标签没有顺序和层次 示例: categories: - Diary tags: - PS3 - Games WordPress 支持对一篇文章设置多个分类, 而且这些分类可以是同级的, 也可以是父子分类. 但 Hexo 不支持指定多个同级分类. 如下的分类, Life 将成为 Diary 的子分类. categories - Diary - Life JSON Front-matter可以使用 JSON 来编写 Front-matter, 只需将 --- 替换为 ;;; 即可: &quot;title&quot;: &quot;Hello World&quot; &quot;date&quot;: &quot;2013/7/12 20:46:25&quot; ;;; 标签插件(Tag Plugins)标签插件和 Front-matter 中的标签不同, 标签插件是用于在文章中快速插入特定内容的插件 引用块在文章中插入引言, 可包含作者, 来源 和 标题. 格式 {% blockquote [author[, source]] [link] [source_link_title] %} CONTENT {% endblockquote %} 示例 # 引用网络上的文章 {% blockquote Seth Godin http://sethgodin.typepad.com/seths_blog/2009/07/welcome-to-island-marketing.html Welcome to Island Marketing %} Every interaction is both precious and an opportunity to delight. {% endblockquote %} # 引用书上的句子 {% blockquote David Levithan, Wide Awake %} Do not just seek happiness for yourself. Seek happiness for all. Through kindness. Through mercy. {% endblockquote %} 代码块在文章中插入代码. 格式 {% codeblock [title] [lang:language] [url] [link text] %} CODE_SNIPPET {% endcodeblock %} 示例 # 附加说明和网址 {% codeblock _.compact http://underscorejs.org/#compact Underscore.js %} _.compact([0, 1, false, 2, '', 3]); => [1, 2, 3] {% endcodeblock %} # 指定语言 {% codeblock lang:objc %} [rectangle setX: 10 y: 10 width: 20 height: 20]; {% endcodeblock %} 反引号代码块使用三个反引号类包裹的代码块: ``` [language] [title] [url] [link text] code snippet ``` Pull Quote{% pullquote [class] %} content {% endpullquote %} jsFiddle{% jsfiddle shorttag [tabs] [skin] [width] [height] %} Gist{% gist gist_id [filename] %} 3iframe{% iframe url [width] [height] %} Image{% img [class names] /path/to/image [width] [height] [title text [alt text]] %} Link在文章中插入链接, 并自动给外部链接添加 target=&quot;_blank&quot; {% link text url [external] [title] %} Include Code插入source文件夹内的代码文件. {% include_code [title] [lang:language] path/to/file %} Youtube插入 Youtube 视频. {% youtube video_id %} Vimeo插入 vimeo 视频 {% vimeo video_id %} 引用文章引用其他文章的链接. {% post_path slug %} {% post_link slug [title] %} 引用资源引用文章的资源 {% asset_path slug %} {% asset_img slug [title] %} {% asset_link slug [title] %} Raw如果希望在文章中插入 Swig 标签, 可以尝试使用 Raw 标签, 以免发生解析异常. {% raw %} content {% endraw %} 资源文件夹资源Asset代表 source 文件夹中除了文章以外的所有文件, 如图片,CSS,JS文件等. 如在 source/images 文件夹中的图片, 可以使用类似于![](/images/NAME.jpg) 方法访问他们. 文章资源文件夹更加组织化的管理资源, 可以通过修改 config.yml 文件中的 post_asset_folder 选项设为 true 来打开. post_asset_folder: true 打开资源文件管理功能之后, Hexo 将会在每一次通过 hexo new [layout] &lt;title&gt; 命令创建新文章时自动创建一个文件夹. 这个资源文件夹间会有与这个 markdown 文件一样的名字. 将所有与该文章有关的资源放在这个关联文件夹中之后, 可以通过相对路径来引用这些资源, 这样就得到了一个更简单而且方便的得多的工作流. 相对路径引用的标签插件通过常规的 markdown 语法和相对路径来引用图片和其他资源可能会导致他们在存档页和主页上显示不正常. 可以使用如下方式引用资源, 解决这个问题: {% asset_path slug %} {% asset_img slug [title] %} {% asset_link slug [title] %} 如, 当打开文章资源文件夹功能后, 资源文件夹中有一个 example.jpg 图片, 正确的引用该图片的方式是使用如下的标签插件, 而不是 markdown, 该图片将会同时出现在文章和主页及归档页中: {% asset_img example.jpg This is an example image %} 数据文件有时, 可能需要在主题中使用某些资料, 而这些资料并不在文章内, 并且是需要重复使用的, 那么可以使用 Hexo 3.0 新增的 数据文件功能, 此功能会载入 source/_data 内的 YAML 或 JSON 文件, 以方便在网站中复用这些文件. # source/_date/menu.yml Home: / Gallery: /gallery/ Archives: /archives/ # 在模板中引用这些资料: &lt;% for (var link in site.data.menu) { %&gt; &lt;a href=&quot;&lt;%= site.data.menu[link] %&gt;&quot;&gt; &lt;%= link %&gt; &lt;/a&gt; &lt;% } %&gt; # 渲染结果 &lt;a href=&quot;/&quot;&gt; Home &lt;/a&gt; &lt;a href=&quot;/gallery/&quot;&gt; Gallery &lt;/a&gt; &lt;a href=&quot;/archives&quot;&gt; Archives &lt;/a&gt; 服务器hexo-serverHexo 3.0 把服务器独立成了个别模块, 必须先安装 hexo-server 才能使用. # 安装 $ npm install hexo-server --save # 启动服务器, 默认 http://localhost:4000 $ hexo server [-p PORT] [-i IP_ADDRESS] [-s] -s : 静态模式, 服务器只处理 public 文件夹内的文件, 而不会处理文件变动, 在执行时, 应该先自行执行 hexo generate, 常用于生产环境. -i IP_ADDRESS : 指定IP地址, 默认为 0.0.0.0 . -p PORT : 指定监听端口. PowPow 是 Mac 系统上的零配置 Rack 服务器, 他也可以作为一个简单易用的静态文件服务器来使用. # 安装 $ curl get.pow.cx | sh # 设置: 在 ~/.pow 文件夹建立链接(symlink) $ cd ~/.pow $ ln -s /path/to/myapp # 网站将在 http://myapp.dev 下运行, 网址根据链接名称而定. 生成器生成文件:$ hexo generate [--watch] --watch : 监视文件变动并立即重新生成静态文件. 在生成时对比文件的 SHA1 , 只有变动的文件才会写入. 完成后部署如下两个命令功能相同, 让 Hexo 在生成完毕后自动部署网站. $ hexo generate --deploy $ hexo g -d # 上述命令的简写 $ hexo deploy --generate $ hexo d -g # 上述命令的简写 部署部署步骤 $ vim _config.yml deploy: type: git $ hexo deploy git 部署# 安装 hexo-deployer-git $ npm install hexo-deployer-git --save # 修改 _config.yml deploy: type: git repo: &lt;REPOSITORY URL&gt; branch: &lt;GIT BRANCH&gt; message: &lt;自定义提交信息&gt; # 默认为 Site updated: {{ now('YYYY-MM-DD HH:mm:ss') }} # 部署 $ hexo deploy Heroku 部署# 安装 hexo-deployer-heroku $ npm install hexo-deployer-heroku --save # 修改 _config.yml deploy: type: heroku repo: &lt;REPOSITORY URL&gt; message: &lt;自定义提交信息&gt; # 默认为 Site updated: {{ now('YYYY-MM-DD HH:mm:ss') }} # 部署 $ hexo deploy 自定义永久链接(Permalink)https://hexo.io/zh-cn/docs/permalinks.html 主题修改主题 在 themes 文件夹内, 创建一个任意名称的文件夹, 修改 _config.yml 内的 theme 设定, 即可切换主体题 主题目录结构. ├── _config.yml ├── languages ├── layout ├── scripts └── source _config.yml主体的配置文件, 修改时会自动更新, 无需重启服务器. languages语言文件夹, 参见国际化 layout布局文件夹, 用于存放主题的模板文件, 决定网站内容的呈现方式. Hexo 内建 Swig 模板引擎, 可以另外安装插件来获得 EJS, Haml, Jade 支持, Hexo 根据模板文件的扩展名来决定所使用的模板引擎. scripts脚本文件夹, 在启动时, Hexo 会自定载入此文件夹内的 JavaScript 文件. source资源文件夹, 除了模板以外的 Asset, 如 CSS , JavaScript 文件等, 都应该放在这个文件夹中. 文件或文件夹前缀为 _ (下划线) 或 隐藏的文件会被忽略. 如果文件可以被渲染的话, 会经过解析然后存储到 public 文件夹, 否则会直接拷贝到 public 文件夹. 模板https://hexo.io/zh-cn/docs/templates.html 变量https://hexo.io/zh-cn/docs/variables.html 辅助函数https://hexo.io/zh-cn/docs/helpers.html#toc 国际化(i18n)https://hexo.io/zh-cn/docs/internationalization.html 插件https://hexo.io/zh-cn/docs/plugins.html nexThttp://theme-next.iissnan.com/getting-started.html#third-party-services 参考文档hexo-theme-nexthexo-wiki hexo 文档 - 中文hexo 文档 - 英文nexT 主题配置文档]]></content>
      <categories>
        <category>Tools</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>nexT</tag>
      </tags>
  </entry>
</search>
